<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>å¦å…‹å¤§æˆ˜ï¼ˆ2000ï¼‰</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, "PingFang SC", "Microsoft YaHei", sans-serif;
      background:
        radial-gradient(1200px 900px at 50% -10%, #2b3c68 0%, #0b0f14 45%, #070a0f 100%);
      color:#e8eef6;
      overflow:hidden;
      -webkit-user-select:none;
      user-select:none;
      touch-action:none;
    }

    .app{
      min-height:100dvh;
      height:100%;
      display:grid;
      /* extra row for mobile touch controls (shown only on touch devices) */
      grid-template-rows:auto 1fr auto auto;
      gap:10px;
      padding:14px 14px calc(14px + env(safe-area-inset-bottom));
      box-sizing:border-box;
      max-width:980px;
      margin:0 auto;
    }

    .topbar, .footer{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 12px;
      border:1px solid rgba(255,255,255,0.10);
      background: rgba(10,14,20,0.55);
      backdrop-filter: blur(10px);
      border-radius:14px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    .brand{ display:flex; align-items:center; gap:10px; min-width:0; }
    .logo{
      width:34px; height:34px; border-radius:10px;
      background: linear-gradient(135deg, rgba(74,222,128,0.95), rgba(96,165,250,0.95));
      box-shadow: 0 12px 20px rgba(0,0,0,0.32);
      position:relative; overflow:hidden;
    }
    .logo:after{
      content:"";
      position:absolute; inset:-18px;
      background: conic-gradient(from 120deg, rgba(255,255,255,0), rgba(255,255,255,0.25), rgba(255,255,255,0));
      animation: spin 2.8s linear infinite;
      opacity:0.65;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .title{ font-weight: 850; letter-spacing: 0.3px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .sub{ font-size:12px; opacity:0.75; }

    .stats{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end; font-size:13px; }
    .pill{
      display:flex; align-items:center; gap:6px;
      padding:6px 10px; border-radius:999px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(11,18,32,0.65);
    }
    
    .pillBtn{
      cursor:pointer;
      user-select:none;
      -webkit-user-select:none;
      appearance:none;
      -webkit-appearance:none;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(11,18,32,0.65);
      color:#e8eef6;
      font:inherit;
      line-height:1;
      display:flex;
      align-items:center;
      gap:6px;
    }
    .pillBtn:hover{ background: rgba(17,28,48,0.82); }
    .pillBtn:active{ transform: translateY(1px); }
    .pillBtn .fsIcon{ font-size:14px; margin-top:-1px; }
.dot{ width:8px; height:8px; border-radius:99px; background: rgba(255,255,255,0.35); }
    .dot.green{ background: rgba(74,222,128,0.95); }
    .dot.blue{ background: rgba(96,165,250,0.95); }
    .dot.red{ background: rgba(255,107,107,0.95); }

    .stage{ display:flex; align-items:center; justify-content:center; position:relative; min-height:0; }
    canvas#game{
      /* Fit within BOTH width and height on short mobile screens.
         60vh leaves room for footer + touch controls without clipping gameplay. */
      width: min(92vw, 60vh, 512px);
      height: auto;
      aspect-ratio: 1/1;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.12);
      background:#0f1624;
      box-shadow: 0 18px 60px rgba(0,0,0,0.48);
      image-rendering: auto;
      touch-action:none;
    }

    .footer .hint{ font-size:12px; opacity:0.72; line-height:1.35; }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      padding:2px 7px;
      border:1px solid rgba(255,255,255,0.14);
      border-bottom-width:2px;
      border-radius: 8px;
      background: rgba(11,18,32,0.85);
      display:inline-block;
      margin: 0 2px;
    }
    .btns{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end; }
    .btn{
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(11,18,32,0.70);
      color:#e8eef6;
      padding:10px 12px;
      border-radius:14px;
      font-weight:800;
      letter-spacing:0.3px;
      cursor:pointer;
      box-shadow: 0 10px 22px rgba(0,0,0,0.25);
      transition: transform .08s ease, background .15s ease, border-color .15s ease, opacity .15s ease;
    }
    .btn:active{ transform: translateY(1px) scale(0.995); }
    .btn.primary{
      background: linear-gradient(135deg, rgba(74,222,128,0.24), rgba(96,165,250,0.22));
      border-color: rgba(255,255,255,0.18);
    }
    .btn.danger{
      background: linear-gradient(135deg, rgba(255,107,107,0.22), rgba(255,193,7,0.08));
    }

    /* Touch controls (mobile). Placed in its own fixed bar BELOW the footer so it won'té®æŒ¡æ¸¸æˆç”»é¢ */
    #touchBar{
      display:none;
      gap:12px;
      align-items:stretch;
      justify-content:space-between;
      padding:10px 12px calc(10px + env(safe-area-inset-bottom));
      border:1px solid rgba(255,255,255,0.10);
      background: rgba(10,14,20,0.50);
      backdrop-filter: blur(10px);
      border-radius:18px;
      box-shadow: 0 16px 40px rgba(0,0,0,.32);
      touch-action:none;
      -webkit-user-select:none;
      user-select:none;
    }
    @media (pointer: coarse), (hover: none){
      #touchBar{ display:flex; }
      /* On phones, hide desktop keyboard legend to free vertical space */
      .footer .hint{ display:none; }
    }

    /* On touch devices, hide the PC keyboard hint to save vertical space. */
    @media (pointer: coarse), (hover: none){
      .footer .hint{ display:none; }
    }

    /* Make touch controls more compact on very small screens */
    @media (max-width: 420px){
      .pad{ grid-template-columns:48px 48px 48px; grid-template-rows:48px 48px 48px; gap:8px; }
      .tbtn{ width:48px; height:48px; border-radius:14px; }
      .spacer{ width:48px; height:48px; }
      .tbtn.fire{ width:88px; height:88px; border-radius:20px; }
      .tbtn.pause{ width:88px; height:52px; }
      #touchBar{ padding:8px 10px calc(8px + env(safe-area-inset-bottom)); }
    }
    .pad{
      display:grid;
      grid-template-columns:56px 56px 56px;
      grid-template-rows:56px 56px 56px;
      gap:10px;
      align-items:center;
      justify-items:center;
    }
    .tbtn{
      width:56px; height:56px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(11,18,32,.72);
      box-shadow: 0 10px 22px rgba(0,0,0,.25);
      color:#e8eef6;
      display:flex; align-items:center; justify-content:center;
      font-weight:900;
      letter-spacing:.4px;
      touch-action:none;
    }
    .tbtn:active{ transform: translateY(1px) scale(0.99); }
    .tbtn.fire{
      width:96px; height:96px;
      border-radius:22px;
      background: linear-gradient(135deg, rgba(96,165,250,.22), rgba(74,222,128,.18));
      border-color: rgba(255,255,255,.18);
      font-size:14px;
    }
    .tbtn.pause{
      width:96px; height:56px;
      border-radius:16px;
      font-size:13px;
      opacity:.95;
    }
    .actions{
      display:flex;
      flex-direction:column;
      gap:10px;
      align-items:flex-end;
      justify-content:center;
    }
    .spacer{ width:56px; height:56px; opacity:0; }

    /* Extra-compact layout for very small phones */
    @media (max-width: 420px){
      .pad{
        grid-template-columns:48px 48px 48px;
        grid-template-rows:48px 48px 48px;
        gap:8px;
      }
      .tbtn{ width:48px; height:48px; border-radius:14px; }
      .tbtn.fire{ width:88px; height:88px; border-radius:20px; }
      .tbtn.pause{ width:88px; height:48px; border-radius:14px; }
      .spacer{ width:48px; height:48px; }
    }

    /* Touch controls are shown only on touch devices (see #touchBar below). */

    .start-overlay{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      background: rgba(0,0,0,0.45);
      backdrop-filter: blur(6px);
      border-radius: 18px;
    }
    .hidden{ display:none !important; }
    .start-card{
      pointer-events:auto;
      width: min(430px, 86%);
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(11,18,32,0.72);
      box-shadow: 0 22px 60px rgba(0,0,0,0.5);
      padding: 16px 16px 14px;
    }
    .start-card h2{ margin:0 0 8px; font-size:20px; }
    .start-card p{ margin:0 0 12px; opacity:0.82; font-size:13px; line-height:1.55; }
    .start-row{ display:flex; gap:10px; justify-content:flex-end; align-items:center; flex-wrap:wrap; }
    .tiny{ font-size:12px; opacity:0.68; }

    @media (max-width: 560px){
      .app{ padding:12px 12px calc(12px + env(safe-area-inset-bottom)); }
      .topbar, .footer{ border-radius:16px; }
    }

    /* Extra compact touch layout for very small screens */
    @media (max-width: 420px){
      .pad{ grid-template-columns:48px 48px 48px; grid-template-rows:48px 48px 48px; gap:8px; }
      .tbtn{ width:48px; height:48px; border-radius:14px; }
      .tbtn.fire{ width:84px; height:84px; border-radius:20px; }
      .tbtn.pause{ width:84px; height:48px; }
    }
  
  .homeLink{
    position:fixed; left:14px; top:14px; z-index:50;
    font-size:12px; padding:8px 10px; border-radius:12px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(0,0,0,.35);
    color:#e8f0ff; text-decoration:none;
    backdrop-filter: blur(8px);
  }
  .homeLink:hover{ border-color: rgba(96,165,250,.75); }

</style>
</head>
<body>
  <a class="homeLink" href="../../index.html" target="_top">â† è¿”å›å¤§å…</a>
  <div class="app">
    <div class="topbar">
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div style="min-width:0">
          <div class="title">å¦å…‹å¤§æˆ˜ï¼ˆ2000ï¼‰</div>
          <div class="sub">Modern FX Â· Keyboard / Mouse Â· Audio</div>
        </div>
      </div>
      <div class="stats">
        <div class="pill"><span class="dot green"></span>å¾—åˆ† <b id="score">0</b></div>
        <div class="pill"><span class="dot green"></span>ç”Ÿå‘½ <b id="hp">4</b>/<b id="hpMax">4</b></div>
        <div class="pill"><span class="dot blue"></span>æ•Œäºº <b id="enemies">0</b></div>
        <div class="pill"><span class="dot red"></span>çŠ¶æ€ <b id="status">è¿è¡Œä¸­</b></div>
        <button class="pill pillBtn" id="fullscreenBtn" type="button" title="è¿›å…¥/é€€å‡ºå…¨å±ï¼ˆéšè—æµè§ˆå™¨åœ°å€æ ï¼Œè§£å†³è™šæ‹ŸæŒ‰é”®é®æŒ¡ï¼‰"><span class="fsIcon" aria-hidden="true">â›¶</span><span id="fsText">å…¨å±æ˜¾ç¤º</span></button>
        <button class="pill pillBtn" id="levelBtn" type="button" title="é€‰æ‹©åœºåœ°ï¼ˆåœºåœ°1ï¼šç»å…¸ï¼›åœºåœ°2ï¼šå¾®è¿·å®«æ›´éš¾ï¼›åœºåœ°3ï¼šæ²™äºŒé£æ ¼ï¼‰"><span class="fsIcon" aria-hidden="true">ğŸ—ºï¸</span><span id="levelText">åœºåœ°1</span></button>
      </div>
    </div>

    <div class="stage">
      <canvas id="game" width="512" height="512"></canvas>

      <div class="start-overlay" id="startOverlay">
        <div class="start-card">
          <h2>ç‚¹å‡»å¼€å§‹</h2>
          <p>
            ä¸ºäº†åœ¨æ‰‹æœºç«¯æ’­æ”¾éŸ³ä¹/éŸ³æ•ˆï¼Œéœ€è¦ä¸€æ¬¡ç”¨æˆ·äº¤äº’æ¥è§£é”éŸ³é¢‘ã€‚éŸ³æ•ˆå·²å†…ç½®ï¼ˆå‡»å‘/å—å‡»/çˆ†ç‚¸ï¼‰ï¼Œå¯åœ¨åº•éƒ¨å¼€å…³ã€‚<br/>
            èƒŒæ™¯éŸ³ä¹è¯·æ”¾åˆ° <span class="kbd">audio/éŸ³ä¹.mp3</span>ï¼ˆå¯é€‰ï¼‰ã€‚
          </p>
          <div class="start-row">
            <span class="tiny">æç¤ºï¼š<span class="kbd">P</span> æš‚åœ / ç»§ç»­</span>
            <button class="btn primary" id="startBtn">å¼€å§‹æ¸¸æˆ</button>
          </div>
        </div>
      </div>
    </div>


      <div class="start-overlay hidden" id="levelOverlay" role="dialog" aria-modal="true" aria-label="é€‰æ‹©åœºåœ°">
        <div class="start-card">
          <h2>é€‰æ‹©åœºåœ°</h2>
          <p>
            <b>åœºåœ°1</b>ï¼šç»å…¸åœ°å›¾ï¼ˆæ›´é€‚åˆä¼‘é—²ï¼‰ã€‚<br/>
            <b>åœºåœ°2</b>ï¼šå¾®è¿·å®«åœ°å›¾ï¼ˆæ›´éš¾ã€æ›´å¤æ‚ï¼‰ã€‚<br/>
            <b>åœºåœ°3</b>ï¼šæ²™äºŒé£æ ¼åœ°å›¾ï¼ˆDust2 å¯å‘çš„å¹³é¢æ„é€ ï¼šAé•¿ / ä¸­è·¯ / Bæ´ / Bé—¨ï¼‰ã€‚<br/>
            <b>åœºåœ°4</b>ï¼šç‚¼ç‹±å°é•‡é£æ ¼åœ°å›¾ï¼ˆInferno å¹³é¢å¸ƒå±€ 1:1 è¿˜åŸï¼šä¸­è·¯ / é¦™è•‰é“ / A / Bï¼‰ã€‚</p>
          <div class="start-row" style="gap:10px; flex-wrap:wrap">
            <button class="btn" data-level="1">åœºåœ°1ï¼ˆç»å…¸ï¼‰</button>
            <button class="btn" data-level="2">åœºåœ°2ï¼ˆè¿·å®«ï¼‰</button>
            <button class="btn primary" data-level="3">åœºåœ°3ï¼ˆæ²™äºŒé£æ ¼ï¼‰</button>
            <button class="btn" data-level="4">åœºåœ°4ï¼ˆç‚¼ç‹±å°é•‡ï¼‰</button>
          </div>
          <div class="tiny" style="opacity:.9; margin-top:10px">åˆ‡æ¢åœºåœ°ä¼šç«‹å³é‡å¼€æœ¬å±€</div>
          <div class="tiny" style="opacity:.7">ç‚¹å‡»é®ç½©åŒºåŸŸå¯å…³é—­</div>
        </div>
      </div>

    <div class="footer">
      <div class="hint">
        <div>æ¡Œé¢ï¼š<span class="kbd">æ–¹å‘é”®</span>/<span class="kbd">WASD</span> ç§»åŠ¨ï¼Œ<span class="kbd">é¼ æ ‡å·¦é”®</span>/<span class="kbd">Space</span> å¼€ç«</div>
        <div><span class="kbd">P</span> æš‚åœï¼Œ<span class="kbd">R</span> é‡å¼€</div>
      </div>
      <div class="btns">
        <button class="btn" id="pauseBtn" title="æš‚åœ/ç»§ç»­ï¼ˆPï¼‰">æš‚åœ</button>
        <button class="btn" id="toggleAudioBtn" title="å¼€å¯/å…³é—­èƒŒæ™¯éŸ³ä¹">éŸ³ä¹ï¼šå¼€</button>
        <button class="btn" id="toggleSfxBtn" title="å¼€å¯/å…³é—­éŸ³æ•ˆ">éŸ³æ•ˆï¼šå¼€</button>
        <button class="btn danger" id="restartBtn">é‡å¼€</button>
      </div>
    </div>

    <!-- Touch controls bar (mobile). Placed BELOW the footer so it won'té®æŒ¡æ¸¸æˆç”»é¢ -->
    <div id="touchBar" aria-label="Touch Controls">
      <div class="pad" aria-label="D-Pad">
        <div class="spacer"></div>
        <div id="btnUp" class="tbtn" role="button" aria-label="Up">â–²</div>
        <div class="spacer"></div>

        <div id="btnLeft" class="tbtn" role="button" aria-label="Left">â—€</div>
        <div class="spacer"></div>
        <div id="btnRight" class="tbtn" role="button" aria-label="Right">â–¶</div>

        <div class="spacer"></div>
        <div id="btnDown" class="tbtn" role="button" aria-label="Down">â–¼</div>
        <div class="spacer"></div>
      </div>

      <div class="actions" aria-label="Actions">
        <div id="btnFire" class="tbtn fire" role="button" aria-label="Fire">å¼€ç«</div>
        <div id="btnPause2" class="tbtn pause" role="button" aria-label="Pause">æš‚åœ</div>
      </div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  let game = null;

  // Fullscreen toggle: used to hide browser address bar / UI so mobile virtual buttons are not blocked.
  const fullscreenBtn = document.getElementById("fullscreenBtn");
  const fullscreenText = document.getElementById("fsText");
  const rootEl = document.documentElement;
  const canRequestFs = !!(rootEl.requestFullscreen || rootEl.webkitRequestFullscreen);

  const updateFsUI = () => {
    if (!fullscreenBtn) return;
    const on = !!(document.fullscreenElement || document.webkitFullscreenElement);
    if (fullscreenText) fullscreenText.textContent = on ? "é€€å‡ºå…¨å±" : "å…¨å±æ˜¾ç¤º";
    fullscreenBtn.disabled = !canRequestFs;
    fullscreenBtn.style.opacity = canRequestFs ? "" : "0.5";
    fullscreenBtn.setAttribute("aria-pressed", on ? "true" : "false");
  };

  const requestFs = async () => {
    if (!canRequestFs) return;
    try {
      if (rootEl.requestFullscreen) {
        await rootEl.requestFullscreen({ navigationUI: "hide" });
      } else if (rootEl.webkitRequestFullscreen) {
        rootEl.webkitRequestFullscreen();
      }
    } catch (e) {
      console.warn("requestFullscreen failed:", e);
    }
  };

  const exitFs = async () => {
    try {
      if (document.exitFullscreen) await document.exitFullscreen();
      else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
    } catch (e) {
      console.warn("exitFullscreen failed:", e);
    }
  };

  if (fullscreenBtn) {
    fullscreenBtn.addEventListener("click", async () => {
      const on = !!(document.fullscreenElement || document.webkitFullscreenElement);
      if (on) await exitFs();
      else await requestFs();

      // Small fallback: some mobile browsers keep a tiny UI barâ€”nudge scroll a bit.
      setTimeout(() => window.scrollTo(0, 1), 50);
      setTimeout(() => window.scrollTo(0, 0), 250);
    });

    document.addEventListener("fullscreenchange", updateFsUI);
    document.addEventListener("webkitfullscreenchange", updateFsUI);

    updateFsUI();
  }

  // Level selection UI (Map 1 / Map 2)
  const levelBtn = document.getElementById("levelBtn");
  const levelText = document.getElementById("levelText");
  const levelOverlay = document.getElementById("levelOverlay");

  const normLevel = (v) => {
    const n = parseInt(v, 10);
    return (n===2 || n===3 || n===4) ? n : 1;
  };
  const getStoredLevel = () => {
    try { return normLevel(localStorage.getItem("tank_level") || "1"); } catch(_){ return 1; }
  };
  const setStoredLevel = (lv) => { try{ localStorage.setItem("tank_level", String(lv)); }catch(_){} };

  const syncLevelUI = (lv = getStoredLevel()) => {
    if (levelText) levelText.textContent = (lv===4 ? "åœºåœ°4" : (lv===3 ? "åœºåœ°3" : (lv===2 ? "åœºåœ°2" : "åœºåœ°1")));
  };
  syncLevelUI();

  if (levelBtn && levelOverlay){
    levelBtn.addEventListener("click", () => {
      levelOverlay.classList.remove("hidden");
    });
    levelOverlay.addEventListener("click", (e) => {
      if (e.target === levelOverlay) levelOverlay.classList.add("hidden");
    });
    levelOverlay.querySelectorAll("[data-level]").forEach((btn) => {
      btn.addEventListener("click", () => {
        const lv = normLevel(btn.getAttribute("data-level"));
        setStoredLevel(lv);
        syncLevelUI(lv);
        levelOverlay.classList.add("hidden");
        if (game) game.setLevel(lv);
      });
    });
  }

const CANVAS_SIZE = 512;
  const TILE_SIZE = 16;
  const GRID = CANVAS_SIZE / TILE_SIZE;

  // Gameplay tuning
  const PLAYER_MAX_HP = 4;          // player must be hit >= 4 times to die
  const VISION_RADIUS = 160;        // px, circular sight radius for both player & AI
  const VISION_RADIUS_SQ = VISION_RADIUS * VISION_RADIUS;

  const TILE = { EMPTY: 0, BRICK: 1, GRASS: 2, WATER: 3 };
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const lerp = (a, b, t) => a + (b - a) * t;

  function rectsIntersect(ax, ay, aw, ah, bx, by, bw, bh) {
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }
  function angleLerp(a, b, t) {
    let d = (b - a + Math.PI) % (Math.PI * 2) - Math.PI;
    return a + d * t;
  }
  function rand(a, b) { return a + Math.random() * (b - a); }

  // --- small drawing helpers (for modern flat + depth) ---
  function rrPath(ctx, x, y, w, h, r){
    r = Math.max(0, Math.min(r, w/2, h/2));
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }
  function hexToRgb(hex){
    const h = (hex||"").replace("#","");
    if (h.length === 3){
      const r = parseInt(h[0]+h[0],16), g=parseInt(h[1]+h[1],16), b=parseInt(h[2]+h[2],16);
      return {r,g,b};
    }
    if (h.length === 6){
      const r = parseInt(h.slice(0,2),16), g=parseInt(h.slice(2,4),16), b=parseInt(h.slice(4,6),16);
      return {r,g,b};
    }
    return {r:180,g:180,b:180};
  }
  function rgbCss({r,g,b}, a=1){ return `rgba(${r|0},${g|0},${b|0},${a})`; }
  function mixRgb(a,b,t){ return {r: a.r+(b.r-a.r)*t, g:a.g+(b.g-a.g)*t, b:a.b+(b.b-a.b)*t}; }
  function lighten(hex, t){
    const c = hexToRgb(hex), w={r:255,g:255,b:255};
    return rgbCss(mixRgb(c,w,t), 1);
  }
  function darken(hex, t){
    const c = hexToRgb(hex), k={r:0,g:0,b:0};
    return rgbCss(mixRgb(c,k,t), 1);
  }

  class AudioManager {
    constructor() {
      // Separate toggles: BGM and SFX
      this.bgmEnabled = true;
      this.sfxEnabled = true;

      this.ctx = null;
      this.master = null;
      this._unlocked = false;

      this.bgm = new Audio("audio/éŸ³ä¹.mp3");
      this.bgm.loop = true;
      this.bgm.volume = 0.35;

      // Killstreak voice callouts (user-provided mp3s in /audio)
      // Files expected: ä¸€æ€.mp3, åŒæ€.mp3, ä¸‰æ€.mp3, å››æ€.mp3, äº”æ€.mp3
      this.killCallouts = ["ä¸€æ€.mp3","åŒæ€.mp3","ä¸‰æ€.mp3","å››æ€.mp3","äº”æ€.mp3"].map((fn)=>{
        const a = new Audio(`audio/${fn}`);
        a.preload = "auto";
        a.volume = 0.95;
        return a;
      });
    }

    async unlock() {
      if (this._unlocked) return;
      this._unlocked = true;

      // WebAudio for punchy SFX (requires user gesture on mobile)
      try {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.master = this.ctx.createGain();
        this.master.gain.value = 0.9;
        this.master.connect(this.ctx.destination);
        if (this.ctx.state === "suspended") await this.ctx.resume();
      } catch (_) {
        this.ctx = null;
        this.master = null;
      }

      // Try to start BGM (optional file)
      try { if (this.bgmEnabled) await this.bgm.play(); } catch (_) {}
    }

    setBgmEnabled(on) {
      this.bgmEnabled = !!on;
      if (!this.bgmEnabled) { try { this.bgm.pause(); } catch(_){} }
      else { this.bgm.play().catch(()=>{}); }
    }

    setSfxEnabled(on) {
      this.sfxEnabled = !!on;
    }

    playKillCallout(n){
      if (!this.sfxEnabled) return;
      const idx = Math.max(1, Math.min(5, n|0)) - 1;
      const a = this.killCallouts && this.killCallouts[idx];
      if (!a) return;
      try {
        // Stop any currently playing callout first (mobile Safari can drop the 5th+ otherwise)
        if (this.killCallouts){
          for (const k of this.killCallouts){
            try { k.pause(); k.currentTime = 0; } catch(_){}
          }
        }
        a.currentTime = 0;
        a.play().catch(()=>{});
      } catch(_){ }
    }


    // --- SFX synth ---
    _ensure() {
      return !!(this.sfxEnabled && this.ctx && this.master);
    }

    _tone({freq=440, dur=0.06, type="square", gain=0.12, bend=0, attack=0.004, release=0.04} = {}) {
      if (!this._ensure()) return;
      const t0 = this.ctx.currentTime;
      const t1 = t0 + dur;

      const g = this.ctx.createGain();
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(Math.max(0.0002, gain), t0 + attack);
      g.gain.exponentialRampToValueAtTime(0.0001, t1);

      const o = this.ctx.createOscillator();
      o.type = type;
      o.frequency.setValueAtTime(freq, t0);
      if (bend !== 0) o.frequency.exponentialRampToValueAtTime(Math.max(30, freq + bend), t1);

      o.connect(g);
      g.connect(this.master);
      o.start(t0);
      o.stop(t1);
    }

    _noise({dur=0.06, gain=0.12, highpass=0, lowpass=0} = {}) {
      if (!this._ensure()) return;
      const t0 = this.ctx.currentTime;
      const t1 = t0 + dur;

      const bufferSize = Math.max(64, Math.floor(this.ctx.sampleRate * dur));
      const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1);

      const src = this.ctx.createBufferSource();
      src.buffer = buffer;

      let node = src;

      if (highpass > 0) {
        const hp = this.ctx.createBiquadFilter();
        hp.type = "highpass";
        hp.frequency.value = highpass;
        node.connect(hp);
        node = hp;
      }
      if (lowpass > 0) {
        const lp = this.ctx.createBiquadFilter();
        lp.type = "lowpass";
        lp.frequency.value = lowpass;
        node.connect(lp);
        node = lp;
      }

      const g = this.ctx.createGain();
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(Math.max(0.0002, gain), t0 + 0.006);
      g.gain.exponentialRampToValueAtTime(0.0001, t1);

      node.connect(g);
      g.connect(this.master);

      src.start(t0);
      src.stop(t1);
    }

    // Punchy arcade sounds (shoot / hit / boom / player-hit)
    sfxShoot(){
      // bright snap + tiny click
      this._tone({freq: 980, dur: 0.045, type:"square", gain:0.10, bend:-420, attack:0.003, release:0.03});
      this._tone({freq: 520, dur: 0.06, type:"triangle", gain:0.055, bend:-90, attack:0.002, release:0.05});
      this._noise({dur: 0.028, gain:0.03, highpass: 1400});
    }

    sfxHit(){
      // metal-ish zap + grit
      this._tone({freq: 260, dur: 0.07, type:"sawtooth", gain:0.10, bend:-140, attack:0.002, release:0.06});
      this._tone({freq: 110, dur: 0.09, type:"square", gain:0.05, bend:-40, attack:0.002, release:0.08});
      this._noise({dur: 0.06, gain:0.06, highpass: 500, lowpass: 3800});
    }

    sfxPlayerHit(){
      // heavier thud for player feedback
      this._tone({freq: 150, dur: 0.09, type:"triangle", gain:0.13, bend:-55, attack:0.002, release:0.08});
      this._noise({dur: 0.08, gain:0.07, highpass: 250, lowpass: 2200});
    }

    sfxBoom(){
      // low boom + hiss tail
      this._tone({freq: 140, dur: 0.18, type:"triangle", gain:0.16, bend:-80, attack:0.002, release:0.16});
      this._tone({freq: 70, dur: 0.22, type:"sine", gain:0.08, bend:-20, attack:0.002, release:0.20});
      this._noise({dur: 0.16, gain:0.10, highpass: 180, lowpass: 2400});
    }
  }

  
  class Particle {
    constructor(x, y, vx, vy, life, size, kind, color=null, extra=null) {
      this.x=x; this.y=y;
      this.vx=vx; this.vy=vy;
      this.life=life; this.maxLife=life;
      this.size=size;
      this.kind=kind;
      this.color=color;
      this.extra=extra;

      this.rot = (extra && typeof extra.rot === "number") ? extra.rot : rand(0, Math.PI*2);
      this.vr = rand(-6, 6);
    }
    update(dt) {
      this.life -= dt;
      if (this.life <= 0) return false;

      // Damped motion; light gravity for debris/smoke only.
      const damp = Math.pow(0.10, dt);
      this.vx *= damp;
      this.vy *= damp;

      if (this.kind === "debris" || this.kind === "smoke") {
        this.vy += 260*dt;
      }

      this.x += this.vx * dt;
      this.y += this.vy * dt;
      this.rot += this.vr * dt;
      return true;
    }
    draw(ctx) {
      const t = clamp(1 - this.life / this.maxLife, 0, 1); // 0->1
      const a = (1 - t);

      ctx.save();
      ctx.translate(this.x, this.y);

      // Some particles are directional (muzzle flash)
      if (this.kind === "muzzle") ctx.rotate((this.extra && this.extra.rot) || 0);
      else ctx.rotate(this.rot);

      if (this.kind === "debris") {
        ctx.globalAlpha = 0.95 * a;
        const c0 = (this.color || "rgba(210,120,70,1)");
        ctx.fillStyle = c0;
        ctx.shadowColor = "rgba(0,0,0,0.35)";
        ctx.shadowBlur = 4;
        ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
        ctx.shadowBlur = 0;

      } else if (this.kind === "spark") {
        // bright spark streak (additive)
        ctx.globalCompositeOperation = "lighter";
        ctx.globalAlpha = 0.85 * a;
        const len = this.size * (1.2 + t*1.6);
        const grad = ctx.createLinearGradient(-len/2, 0, len/2, 0);
        grad.addColorStop(0, "rgba(255,255,255,0)");
        grad.addColorStop(0.45, this.color || "rgba(250,220,90,1)");
        grad.addColorStop(1, "rgba(255,255,255,0)");
        ctx.strokeStyle = grad;
        ctx.lineWidth = 2.2;
        ctx.lineCap = "round";
        ctx.shadowColor = this.color || "rgba(250,220,90,1)";
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.moveTo(-len/2, 0);
        ctx.lineTo(len/2, 0);
        ctx.stroke();
        ctx.shadowBlur = 0;
        ctx.globalCompositeOperation = "source-over";

      } else if (this.kind === "smoke") {
        // soft smoke puff
        ctx.globalAlpha = 0.18 * a;
        const r = this.size*(1 + t*2.1);
        const g = ctx.createRadialGradient(0, 0, r*0.1, 0, 0, r);
        g.addColorStop(0, "rgba(255,255,255,0.35)");
        g.addColorStop(1, "rgba(200,210,230,0)");
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI*2);
        ctx.fill();

      } else if (this.kind === "ring") {
        // shock ring
        ctx.globalCompositeOperation = "lighter";
        ctx.globalAlpha = 0.16 * a;
        const r = this.size*(1 + t*3.0);
        ctx.strokeStyle = this.color || "rgba(255,255,255,1)";
        ctx.lineWidth = 2.2;
        ctx.shadowColor = this.color || "rgba(255,255,255,1)";
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI*2);
        ctx.stroke();
        ctx.shadowBlur = 0;
        ctx.globalCompositeOperation = "source-over";

      } else if (this.kind === "muzzle") {
        // muzzle flash cone + core
        ctx.globalCompositeOperation = "lighter";
        ctx.globalAlpha = 0.85 * a;

        const col = this.color || "rgba(246,224,94,1)";
        const L = this.size * (1.6 + t*0.2);
        const W = this.size * (0.65 + t*0.15);

        // cone
        const cg = ctx.createLinearGradient(0, 0, L, 0);
        cg.addColorStop(0, "rgba(255,255,255,0.95)");
        cg.addColorStop(0.3, col);
        cg.addColorStop(1, "rgba(255,255,255,0)");
        ctx.fillStyle = cg;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(L, W);
        ctx.lineTo(L, -W);
        ctx.closePath();
        ctx.fill();

        // core
        ctx.fillStyle = "rgba(255,255,255,0.75)";
        ctx.beginPath();
        ctx.arc(0, 0, this.size*0.55, 0, Math.PI*2);
        ctx.fill();

        ctx.globalCompositeOperation = "source-over";
      }

      ctx.restore();
    }
  }


  class FX {
    constructor() {
      this.particles = [];
      this.flash = 0;
      this.shake = 0;
      this.shakeX = 0;
      this.shakeY = 0;

      this._muzzleCooldown = 0;
    }
    update(dt) {
      this.particles = this.particles.filter(p => p.update(dt));
      this.flash = Math.max(0, this.flash - dt * 2.6);
      this.shake = Math.max(0, this.shake - dt * 2.1);

      // slightly smoother shake
      const s = this.shake;
      this.shakeX = (Math.random()*2-1) * 5.5 * s;
      this.shakeY = (Math.random()*2-1) * 5.5 * s;

      this._muzzleCooldown = Math.max(0, this._muzzleCooldown - dt);
    }
    draw(ctx) { for (const p of this.particles) p.draw(ctx); }

    muzzleFlash(x, y, angle, faction="player") {
      // keep it subtle; avoid particle spam on high ROF
      if (this._muzzleCooldown > 0) return;
      this._muzzleCooldown = 0.012;

      const col = (faction === "player") ? "rgba(246,224,94,1)" : "rgba(255,120,120,1)";
      this.particles.push(new Particle(
        x, y, 0, 0,
        0.075, 10,
        "muzzle",
        col,
        {rot: angle}
      ));

      // micro sparks forward
      for (let i=0;i<4;i++){
        const a = angle + rand(-0.25, 0.25);
        const sp = rand(220, 420);
        this.particles.push(new Particle(
          x + Math.cos(a)*6, y + Math.sin(a)*6,
          Math.cos(a)*sp, Math.sin(a)*sp,
          rand(0.08, 0.16),
          rand(4, 7),
          "spark",
          col
        ));
      }

      this.flash = Math.min(1, this.flash + 0.05);
      this.shake = Math.min(1, this.shake + 0.06);
    }

    burstBrick(x, y) {
      // debris + sparks + dust
      for (let i=0;i<16;i++) {
        this.particles.push(new Particle(
          x + rand(-6,6), y + rand(-6,6),
          rand(-240,240), rand(-260,60),
          rand(0.22, 0.55),
          rand(2,3),
          "debris",
          (Math.random()<0.5) ? "rgba(200,95,70,1)" : "rgba(150,70,55,1)"
        ));
      }
      for (let i=0;i<10;i++) {
        this.particles.push(new Particle(
          x + rand(-3,3), y + rand(-3,3),
          rand(-320,320), rand(-320,0),
          rand(0.10, 0.22),
          rand(4,7),
          "spark",
          "rgba(250,220,90,1)"
        ));
      }
      for (let i=0;i<6;i++) {
        this.particles.push(new Particle(
          x + rand(-6,6), y + rand(-6,6),
          rand(-40,40), rand(-140,-20),
          rand(0.30, 0.60),
          rand(3,6),
          "smoke"
        ));
      }
      this.flash = Math.min(1, this.flash + 0.22);
      this.shake = Math.min(1, this.shake + 0.20);
    }

    burstTank(x, y) {
      this.particles.push(new Particle(x, y, 0, 0, 0.35, 9, "ring", "rgba(255,255,255,1)"));
      for (let i=0;i<30;i++) {
        this.particles.push(new Particle(
          x + rand(-7,7), y + rand(-7,7),
          rand(-360,360), rand(-360,180),
          rand(0.20, 0.60),
          rand(2,4),
          (Math.random()<0.55) ? "spark" : "debris",
          (Math.random()<0.55) ? "rgba(255,210,90,1)" : "rgba(170,80,60,1)"
        ));
      }
      for (let i=0;i<12;i++) {
        this.particles.push(new Particle(
          x + rand(-10,10), y + rand(-10,10),
          rand(-60,60), rand(-170,-30),
          rand(0.35, 0.95),
          rand(4,7),
          "smoke"
        ));
      }
      this.flash = Math.min(1, this.flash + 0.55);
      this.shake = Math.min(1, this.shake + 0.60);
    }
  }

class TileMap {
    constructor(w, h, levelId=1) {
      this.w=w; this.h=h;
      this.tiles = new Uint8Array(w*h);
      this.grassDecor = new Array(w*h);
      this.levelId = ((levelId|0)===2 || (levelId|0)===3 || (levelId|0)===4) ? (levelId|0) : 1;
      this.reset(this.levelId);

      // Pre-generated subtle star/noise field to avoid per-frame random flicker
      this.stars = Array.from({length: 55}, () => ({
        x: (Math.random()*CANVAS_SIZE)|0,
        y: (Math.random()*CANVAS_SIZE)|0,
        p: Math.random()*Math.PI*2,
        s: 0.02 + Math.random()*0.05,
      }));


      // Subtle noise texture (makes flat colors feel more modern, without assets)
      this._noiseCanvas = document.createElement("canvas");
      this._noiseCanvas.width = 96;
      this._noiseCanvas.height = 96;
      const nctx = this._noiseCanvas.getContext("2d");
      const img = nctx.createImageData(this._noiseCanvas.width, this._noiseCanvas.height);
      for (let i=0;i<img.data.length;i+=4){
        const v = (Math.random()*255)|0;
        img.data[i]   = v;
        img.data[i+1] = v;
        img.data[i+2] = v;
        img.data[i+3] = 18; // low alpha
      }
      nctx.putImageData(img, 0, 0);
      // a few larger speckles for texture
      nctx.fillStyle = "rgba(255,255,255,0.04)";
      for (let i=0;i<90;i++){
        nctx.fillRect(Math.random()*96, Math.random()*96, 1, 1);
      }
      this._noisePattern = null;
    }
    idx(x,y){ return y*this.w+x; }
    inBounds(x,y){ return x>=0&&y>=0&&x<this.w&&y<this.h; }
    get(x,y){ if(!this.inBounds(x,y)) return TILE.BRICK; return this.tiles[this.idx(x,y)]; }
    set(x,y,t){ if(!this.inBounds(x,y)) return; this.tiles[this.idx(x,y)] = t; }
    isSolid(t){ return t===TILE.BRICK || t===TILE.WATER; }

    reset(levelId=this.levelId||1){
      this.levelId = ((levelId|0)===2 || (levelId|0)===3 || (levelId|0)===4) ? (levelId|0) : 1;
      this.tiles.fill(TILE.EMPTY);
      this.grassDecor.fill(null);



      
      // Level 4: Inferno-inspired (tactical flat layout 1:1 from provided map image)
      if (this.levelId===4){
        const w=this.w, h=this.h;
        // Use WATER as indestructible wall in level 4 (plaster/stone walls)
        this.tiles.fill(TILE.WATER);

        const INFERNO_MASK = [
        "00000000000000011110000000000000",
        "00000000000000011110000000000000",
        "00000000000011111110000000000000",
        "00000000000011111110000000000000",
        "00000000000011111100000000000000",
        "00000000000011111100000000000000",
        "00000000000011111100000001110000",
        "00000000000011111100000001110000",
        "00000000000000000000000011110000",
        "00000000000000000000000011111111",
        "00000000000000000000000011111111",
        "00000000000000000000000001111111",
        "00000000000000000000000001111111",
        "00000000000000000000000001111111",
        "00000000000000000000000001111111",
        "00000000000000000000000001111111",
        "00000000000000000000000001111111",
        "00000000000000000000000111111111",
        "00000000000000000000000111111111",
        "00000000000000000000000111111111",
        "00000000000000000000000000111111",
        "11000000000000000000000000111111",
        "11000000000000000000000000111111",
        "11000000011110000000000000111111",
        "00000000011110000000000000111111",
        "00000000011110000000000000111111",
        "00000000011100000000011111111000",
        "00000000011100000000011111111000",
        "00000000011100000000011111111000",
        "00000000011100000000000000000000",
        "00000000000000000000000000000000",
        "00000000000000000000000000000000",
      ];

        for (let y=0;y<h;y++){
          const row = INFERNO_MASK[y] || "";
          for (let x=0;x<w;x++){
            if (row.charCodeAt(x)===49) { // '1'
              this.set(x,y,TILE.EMPTY);
            }
          }
        }

        // Ensure spawn rooms are clear (safety padding)
        this.clearArea(0, 20, 5, 5);
        this.clearArea(w-6, 5, 6, 6);

        return;
      }

// Level 3: Dust2-inspired (flat layout) â€” Aé•¿ / ä¸­è·¯ / Bæ´ / Bé—¨
      if (this.levelId===3){
        const w=this.w, h=this.h;

        // Use WATER as indestructible sandstone wall in level 3.
        this.tiles.fill(TILE.WATER);

        const carve = (x,y,ww,hh)=>this.clearArea(x,y,ww,hh);
        const fill = (x,y,ww,hh,t=TILE.WATER)=>{
          for(let yy=y;yy<y+hh;yy++) for(let xx=x;xx<x+ww;xx++) this.set(xx,yy,t);
        };

        // ---- Key regions (rough Dust2 structure, adapted for tank movement) ----
        // CT spawn (player) bottom-left
        carve(1, h-7, 10, 6);

        // T spawn (enemy) top-right
        carve(w-11, 1, 10, 7);

        // A site (top-left)
        carve(2, 2, 12, 8);

        // B site (bottom-right)
        carve(w-12, h-12, 10, 10);

        // Mid (center)
        carve(11, 12, 10, 4);

        // A Long (left edge corridor) connects CT <-> A
        carve(2, 8, 4, h-15);
        // Long choke (like Long Doors)
        fill(2, 16, 1, 1, TILE.WATER);
        fill(5, 16, 1, 1, TILE.WATER);

        // Short/Cat (mid -> A)
        carve(9, 10, 4, 4);
        carve(7, 8, 6, 3);
        carve(13, 10, 4, 3); // small connector to mid

        // CT -> Mid connector (lower-mid)
        carve(8, 20, 5, 10);
        carve(11, 15, 3, 6);

        // T -> Mid connector (upper-mid / suicide style)
        carve(w-15, 8, 8, 4);
        carve(18, 9, 6, 3);

        // Tunnels (T spawn -> B)
        carve(w-7, 7, 5, 16);
        carve(w-12, 18, 6, 4); // bend/room before site

        // B Doors (mid -> B)
        carve(20, 15, 4, 7);
        // Doors pinch pillars
        fill(21, 17, 1, 1, TILE.WATER);
        fill(22, 19, 1, 1, TILE.WATER);

        // ---- Breakable cover (crates) for better fights ----
        const crate = (x,y)=>{ if (this.get(x,y)===TILE.EMPTY) this.set(x,y,TILE.BRICK); };
        const crateRect = (x,y,ww,hh,step=2)=>{
          for(let yy=y;yy<y+hh;yy+=step) for(let xx=x;xx<x+ww;xx+=step) crate(xx,yy);
        };

        // A site boxes
        crateRect(4, 4, 7, 5, 2);
        // Mid cover
        crateRect(14, 13, 4, 2, 2);
        crateRect(18, 13, 2, 2, 2);
        // B site cover
        crateRect(w-10, h-10, 7, 7, 2);

        // Decorative "dust decals" (repurpose GRASS tile in level 3 renderer)
        let s = 0xD0572; // deterministic seed
        const rng = () => (s = (s*1664525 + 1013904223) >>> 0) / 4294967296;
        for (let i=0;i<220;i++){
          const x = 2 + ((rng()*(w-4))|0);
          const y = 2 + ((rng()*(h-4))|0);
          if (this.get(x,y)===TILE.EMPTY && rng()<0.28) this.set(x,y,TILE.GRASS);
        }

        // Ensure spawns are open
        carve(1, h-7, 10, 6);
        carve(w-11, 1, 10, 7);

        // Decor points (reused by GRASS renderer)
        for (let y=0;y<this.h;y++){
          for (let x=0;x<this.w;x++){
            const i = this.idx(x,y);
            if (this.tiles[i] !== TILE.GRASS) continue;
            const pts = [];
            let ss = (((x*73856093) ^ (y*19349663)) >>> 0);
            const rr = () => (ss = (ss*1664525 + 1013904223) >>> 0) / 4294967296;
            const count = 3 + ((rr()*5)|0);
            for (let k=0;k<count;k++){
              pts.push({
                x: 2 + Math.floor(rr()*(TILE_SIZE-4)),
                y: 2 + Math.floor(rr()*(TILE_SIZE-4)),
                r: 1 + Math.floor(rr()*2),
              });
            }
            this.grassDecor[i] = pts;
          }
        }

        return;
      }

      // Level 2: Micro-maze (hard) + more premium visual theme
      if (this.levelId===2){
        // Use WATER as indestructible "steel wall" in level 2 (BRICK stays breakable)
        this.tiles.fill(TILE.WATER);

        const w=this.w, h=this.h;
        let s = 0xC0FFEE; // deterministic seed for repeatable maze
        const rng = () => (s = (s*1664525 + 1013904223) >>> 0) / 4294967296;
        const inb = (x,y) => x>0 && x<w-1 && y>0 && y<h-1;

        // Cells on odd coordinates
        for (let y=1;y<h-1;y+=2){
          for (let x=1;x<w-1;x+=2){
            this.set(x,y,TILE.EMPTY);
          }
        }

        // DFS carve
        const visited = new Uint8Array(w*h);
        const stack = [[1,1]];
        visited[this.idx(1,1)] = 1;
        const dirs = [[2,0],[-2,0],[0,2],[0,-2]];
        while(stack.length){
          const top = stack[stack.length-1];
          const cx = top[0], cy = top[1];
          const opts = [];
          for (const d of dirs){
            const nx=cx+d[0], ny=cy+d[1];
            if (!inb(nx,ny)) continue;
            const ii=this.idx(nx,ny);
            if (visited[ii]) continue;
            opts.push([nx,ny,d[0],d[1]]);
          }
          if (opts.length){
            const p = opts[(rng()*opts.length)|0];
            const nx=p[0], ny=p[1], dx=p[2], dy=p[3];
            this.set(cx+dx/2, cy+dy/2, TILE.EMPTY);
            this.set(nx, ny, TILE.EMPTY);
            visited[this.idx(nx,ny)] = 1;
            stack.push([nx,ny]);
          } else {
            stack.pop();
          }
        }

        // Carve a few "rooms" (make routing less linear but still maze-like)
        const rooms = [
          {x:3,y:3,w:7,h:6},
          {x:w-10,y:3,w:7,h:6},
          {x:3,y:h-10,w:7,h:6},
          {x:(w/2-4)|0,y:(h/2-3)|0,w:9,h:7},
        ];
        for (const r of rooms) this.clearArea(r.x,r.y,r.w,r.h);

        // Add breakable cover blocks (BRICK) in wider spaces
        for (let y=1;y<h-1;y++){
          for (let x=1;x<w-1;x++){
            if (this.get(x,y)!==TILE.EMPTY) continue;
            let n=0;
            if (this.get(x+1,y)===TILE.EMPTY) n++;
            if (this.get(x-1,y)===TILE.EMPTY) n++;
            if (this.get(x,y+1)===TILE.EMPTY) n++;
            if (this.get(x,y-1)===TILE.EMPTY) n++;
            if (n>=3 && rng()<0.10) this.set(x,y,TILE.BRICK);
          }
        }

        // Decorative grass (non-blocking)
        for (let y=1;y<h-1;y++){
          for (let x=1;x<w-1;x++){
            if (this.get(x,y)!==TILE.EMPTY) continue;
            if (rng()<0.10) this.set(x,y,TILE.GRASS);
          }
        }

        // Keep spawn areas open
        this.clearArea(1, this.h-4, 5, 3);
        this.clearArea(this.w-6, 1, 5, 3);

        // Connect the spawn rooms to the maze so nobody gets sealed in
        for (let i=0;i<5;i++) this.set(5+i, this.h-5, TILE.EMPTY);        // player door
        for (let i=0;i<5;i++) this.set(this.w-6-i, 4, TILE.EMPTY);        // enemy door

        // Grass decoration points (same logic as level 1)
        for (let y=0;y<this.h;y++){
          for (let x=0;x<this.w;x++){
            const i = this.idx(x,y);
            if (this.tiles[i] !== TILE.GRASS) continue;
            const pts = [];
            let ss = (((x*73856093) ^ (y*19349663)) >>> 0);
            const rr = () => (ss = (ss*1664525 + 1013904223) >>> 0) / 4294967296;
            const count = 4 + ((rr()*6)|0);
            for (let k=0;k<count;k++){
              pts.push({
                x: 2 + Math.floor(rr()*(TILE_SIZE-4)),
                y: 2 + Math.floor(rr()*(TILE_SIZE-4)),
                r: 1 + Math.floor(rr()*2),
              });
            }
            this.grassDecor[i] = pts;
          }
        }

        return;
      }

      for (let x=0;x<this.w;x++){ this.set(x,0,TILE.BRICK); this.set(x,this.h-1,TILE.BRICK); }
      for (let y=0;y<this.h;y++){ this.set(0,y,TILE.BRICK); this.set(this.w-1,y,TILE.BRICK); }

      for (let y=4;y<this.h-4;y++){
        const x = 15 + ((y/4)|0)%2;
        this.set(x,y,TILE.WATER); this.set(x+1,y,TILE.WATER);
      }

      const clusters = [
        {x:5,y:6,w:6,h:3},
        {x:20,y:8,w:7,h:3},
        {x:7,y:18,w:5,h:4},
        {x:22,y:20,w:6,h:3},
        {x:12,y:26,w:8,h:3},
      ];
      for (const c of clusters){
        for (let yy=c.y;yy<c.y+c.h;yy++){
          for (let xx=c.x;xx<c.x+c.w;xx++){
            if ((xx+yy)%3!==0) this.set(xx,yy,TILE.BRICK);
          }
        }
      }

      const grass = [
        {x:3,y:3,w:6,h:4},
        {x:23,y:3,w:6,h:4},
        {x:3,y:24,w:6,h:4},
        {x:23,y:24,w:6,h:4},
        {x:12,y:12,w:4,h:4},
      ];
      for (const g of grass){
        for (let yy=g.y;yy<g.y+g.h;yy++){
          for (let xx=g.x;xx<g.x+g.w;xx++){
            if (this.get(xx,yy)===TILE.EMPTY) this.set(xx,yy,TILE.GRASS);
          }
        }
      }

      this.clearArea(1, this.h-3, 4, 2);
      this.clearArea(this.w-5, 1, 4, 2);

      for (let y=0;y<this.h;y++){
        for (let x=0;x<this.w;x++){
          const i = this.idx(x,y);
          if (this.tiles[i] !== TILE.GRASS) continue;
          const pts = [];
          let s = (((x*73856093) ^ (y*19349663)) >>> 0);
          const rng = () => (s = (s*1664525 + 1013904223) >>> 0) / 4294967296;
          for (let k=0;k<7;k++){
            pts.push({
              x: 2 + Math.floor(rng()*(TILE_SIZE-4)),
              y: 2 + Math.floor(rng()*(TILE_SIZE-4)),
              r: 1 + Math.floor(rng()*2),
            });
          }
          this.grassDecor[i] = pts;
        }
      }
    }

    clearArea(x,y,w,h){
      for(let yy=y;yy<y+h;yy++) for(let xx=x;xx<x+w;xx++) this.set(xx,yy,TILE.EMPTY);
    }

    collidesRect(px,py,pw,ph){
      const x0 = Math.floor(px/TILE_SIZE);
      const y0 = Math.floor(py/TILE_SIZE);
      const x1 = Math.floor((px+pw-1)/TILE_SIZE);
      const y1 = Math.floor((py+ph-1)/TILE_SIZE);
      for(let y=y0;y<=y1;y++){
        for(let x=x0;x<=x1;x++){
          if (this.isSolid(this.get(x,y))) return true;
        }
      }
      return false;
    }

    bulletHit(px,py){
      const tx = Math.floor(px/TILE_SIZE);
      const ty = Math.floor(py/TILE_SIZE);
      const t = this.get(tx,ty);
      if (t===TILE.BRICK){
        this.set(tx,ty,TILE.EMPTY);
        return {hit:true, stop:true, kind:"brick", tx, ty};
      }
      if (t===TILE.WATER){
        return {hit:true, stop:true, kind:"water", tx, ty};
      }
      return {hit:false, stop:false, kind:"none", tx, ty};
    }

    draw(ctx, tSec){
      const isMaze = this.levelId===2;
      const isDust = this.levelId===3;
      const isInferno = this.levelId===4;

      if (isMaze){
        // Cached high-fidelity floor for Level 2 (maze)
        if (!this._bg2){
          const c = document.createElement("canvas");
          c.width = this.w*TILE_SIZE;
          c.height = this.h*TILE_SIZE;
          const b = c.getContext("2d");

          const g = b.createLinearGradient(0,0,0,CANVAS_SIZE);
          g.addColorStop(0, "#0b111c");
          g.addColorStop(1, "#060910");
          b.fillStyle = g;
          b.fillRect(0,0,c.width,c.height);

          // micro grid (8px)
          b.strokeStyle = "rgba(255,255,255,0.035)";
          b.lineWidth = 1;
          for (let i=0;i<=c.width;i+=8){ b.beginPath(); b.moveTo(i+0.5,0); b.lineTo(i+0.5,c.height); b.stroke(); }
          for (let i=0;i<=c.height;i+=8){ b.beginPath(); b.moveTo(0,i+0.5); b.lineTo(c.width,i+0.5); b.stroke(); }

          // diagonal brushed metal
          b.strokeStyle = "rgba(255,255,255,0.018)";
          for (let i=-c.height;i<c.width;i+=12){
            b.beginPath();
            b.moveTo(i,0);
            b.lineTo(i+c.height,c.height);
            b.stroke();
          }

          // noise overlay baked
          if (this._noiseCanvas){
            try {
              const p = b.createPattern(this._noiseCanvas, "repeat");
              b.globalAlpha = 0.12;
              b.fillStyle = p;
              b.fillRect(0,0,c.width,c.height);
              b.globalAlpha = 1;
            } catch(_){}
          }

          // vignette
          const vg = b.createRadialGradient(CANVAS_SIZE/2, CANVAS_SIZE/2, 80, CANVAS_SIZE/2, CANVAS_SIZE/2, 420);
          vg.addColorStop(0, "rgba(255,255,255,0.02)");
          vg.addColorStop(1, "rgba(0,0,0,0.42)");
          b.fillStyle = vg;
          b.fillRect(0,0,c.width,c.height);

          this._bg2 = c;
        }
        ctx.drawImage(this._bg2, 0, 0);

        // animated light sweep (premium feel)
        const sx = (0.5 + 0.5*Math.sin(tSec*0.35)) * CANVAS_SIZE;
        const sweep = ctx.createLinearGradient(sx-220, 0, sx+220, CANVAS_SIZE);
        sweep.addColorStop(0, "rgba(255,255,255,0)");
        sweep.addColorStop(0.5, "rgba(120,200,255,0.10)");
        sweep.addColorStop(1, "rgba(255,255,255,0)");
        ctx.globalAlpha = 0.55;
        ctx.fillStyle = sweep;
        ctx.fillRect(0,0,this.w*TILE_SIZE,this.h*TILE_SIZE);
        ctx.globalAlpha = 1;

      } else if (isDust){
        // Cached desert floor for Level 3 (Dust2-inspired)
        if (!this._bg3){
          const c = document.createElement("canvas");
          c.width = this.w*TILE_SIZE;
          c.height = this.h*TILE_SIZE;
          const b = c.getContext("2d");

          const g = b.createLinearGradient(0,0,0,CANVAS_SIZE);
          g.addColorStop(0, "#e7c990");
          g.addColorStop(1, "#b48352");
          b.fillStyle = g;
          b.fillRect(0,0,c.width,c.height);

          // sand ripples
          b.strokeStyle = "rgba(255,255,255,0.040)";
          b.lineWidth = 1;
          for (let i=-c.height;i<c.width;i+=10){
            b.beginPath();
            b.moveTo(i, 0);
            b.lineTo(i + c.height, c.height);
            b.stroke();
          }

          // baked noise grit
          if (this._noiseCanvas){
            try {
              const p = b.createPattern(this._noiseCanvas, "repeat");
              b.globalAlpha = 0.18;
              b.fillStyle = p;
              b.fillRect(0,0,c.width,c.height);
              b.globalAlpha = 1;
            } catch(_){}
          }

          // sun hotspot + warm vignette
          const sun = b.createRadialGradient(CANVAS_SIZE*0.35, CANVAS_SIZE*0.22, 60, CANVAS_SIZE*0.35, CANVAS_SIZE*0.22, 520);
          sun.addColorStop(0, "rgba(255,255,255,0.12)");
          sun.addColorStop(1, "rgba(0,0,0,0.30)");
          b.fillStyle = sun;
          b.fillRect(0,0,c.width,c.height);

          this._bg3 = c;
        }
        ctx.drawImage(this._bg3, 0, 0);

        // light heat-haze sweep (subtle)
        const hx = (0.5 + 0.5*Math.sin(tSec*0.25)) * CANVAS_SIZE;
        const haze = ctx.createLinearGradient(hx-240, 0, hx+240, CANVAS_SIZE);
        haze.addColorStop(0, "rgba(255,255,255,0)");
        haze.addColorStop(0.5, "rgba(255,210,150,0.08)");
        haze.addColorStop(1, "rgba(255,255,255,0)");
        ctx.globalAlpha = 0.75;
        ctx.fillStyle = haze;
        ctx.fillRect(0,0,this.w*TILE_SIZE,this.h*TILE_SIZE);
        ctx.globalAlpha = 1;

      
      } else if (isInferno){
        // Cached Mediterranean stone floor for Level 4 (Inferno-inspired)
        if (!this._bg4){
          const c = document.createElement("canvas");
          c.width = this.w*TILE_SIZE;
          c.height = this.h*TILE_SIZE;
          const b = c.getContext("2d");

          const g = b.createLinearGradient(0,0,0,CANVAS_SIZE);
          g.addColorStop(0, "#e8e2d6");
          g.addColorStop(1, "#bfb3a2");
          b.fillStyle = g;
          b.fillRect(0,0,c.width,c.height);

          // stone tile grid
          b.strokeStyle = "rgba(0,0,0,0.06)";
          b.lineWidth = 1;
          for (let i=0;i<=c.width;i+=16){ b.beginPath(); b.moveTo(i+0.5,0); b.lineTo(i+0.5,c.height); b.stroke(); }
          for (let i=0;i<=c.height;i+=16){ b.beginPath(); b.moveTo(0,i+0.5); b.lineTo(c.width,i+0.5); b.stroke(); }

          // subtle warm noise overlay
          try{
            if (this._noiseCanvas){
              b.globalAlpha = 0.22;
              b.globalCompositeOperation = "overlay";
              b.drawImage(this._noiseCanvas,0,0,c.width,c.height);
              b.globalCompositeOperation = "source-over";
              b.globalAlpha = 1;
            }
          }catch(_){}

          // sun / ambient vignette
          const sun = b.createRadialGradient(CANVAS_SIZE*0.62, CANVAS_SIZE*0.18, 40, CANVAS_SIZE*0.62, CANVAS_SIZE*0.18, 520);
          sun.addColorStop(0, "rgba(255,255,255,0.18)");
          sun.addColorStop(1, "rgba(0,0,0,0.22)");
          b.fillStyle = sun;
          b.fillRect(0,0,c.width,c.height);

          this._bg4 = c;
        }
        ctx.drawImage(this._bg4, 0, 0);

        // very subtle moving light sweep (modern feel)
        ctx.save();
        ctx.globalCompositeOperation = "overlay";
        ctx.globalAlpha = 0.06;
        const sw = 140;
        const sx = ((tSec*22) % (CANVAS_SIZE+sw)) - sw;
        const sweep = ctx.createLinearGradient(sx,0,sx+sw,0);
        sweep.addColorStop(0,"rgba(255,255,255,0)");
        sweep.addColorStop(0.5,"rgba(255,255,255,1)");
        sweep.addColorStop(1,"rgba(255,255,255,0)");
        ctx.fillStyle = sweep;
        ctx.fillRect(0,0,CANVAS_SIZE,CANVAS_SIZE);
        ctx.restore();

      } else {
        const g = ctx.createLinearGradient(0,0,0,CANVAS_SIZE);
        g.addColorStop(0, "#0f1b2c");
        g.addColorStop(1, "#0b1220");
        ctx.fillStyle = g;
        ctx.fillRect(0,0,this.w*TILE_SIZE,this.h*TILE_SIZE);
      }

      // subtle noise overlay (one-time pattern)
      if (!isMaze && !isDust && !this._noisePattern && this._noiseCanvas){
        try { this._noisePattern = ctx.createPattern(this._noiseCanvas, "repeat"); } catch(_) { this._noisePattern = null; }
      }
      if (!isMaze && !isDust && this._noisePattern){
        ctx.globalAlpha = 0.10;
        ctx.fillStyle = this._noisePattern;
        ctx.fillRect(0,0,this.w*TILE_SIZE,this.h*TILE_SIZE);
        ctx.globalAlpha = 1;
      }

      const starMul = isMaze ? 0.06 : (isDust ? 0 : 1);

      // subtle star field (stable positions; animated alpha)
      ctx.fillStyle = "rgba(255,255,255,1)";
      for (const s of this.stars){
        const a = 0.01 + (0.5 + 0.5*Math.sin(tSec*1.5 + s.p)) * s.s;
        ctx.globalAlpha = a * starMul;
        ctx.fillRect(s.x, s.y, 1, 1);
      }
      ctx.globalAlpha = 1;
      if (!isMaze && !isDust){
        ctx.strokeStyle = "rgba(255,255,255,0.025)";
        ctx.lineWidth = 1;
        for (let i=0;i<=this.w;i++){
          const x = i*TILE_SIZE + 0.5;
          ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,this.h*TILE_SIZE); ctx.stroke();
        }
        for (let i=0;i<=this.h;i++){
          const y = i*TILE_SIZE + 0.5;
          ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(this.w*TILE_SIZE,y); ctx.stroke();
        }
      }


      for(let y=0;y<this.h;y++){
        for(let x=0;x<this.w;x++){
          const tt = this.get(x,y);
          if (tt===TILE.EMPTY || tt===TILE.GRASS) continue;
          this.drawTile(ctx,x,y,tt,tSec);
        }
      }

      // (Removed) moving highlight sweep bars â€” was visually distracting.

    }

    drawGrassOverlay(ctx){
      for(let y=0;y<this.h;y++){
        for(let x=0;x<this.w;x++){
          if (this.get(x,y)===TILE.GRASS) this.drawTile(ctx,x,y,TILE.GRASS,0);
        }
      }
    }

    drawTile(ctx,x,y,t, tSec){
      const px=x*TILE_SIZE, py=y*TILE_SIZE;


      
      // Level 4 tile shading: Inferno â€” plaster/stone walls (uses WATER for collision)
      if (this.levelId===4){
        if (t===TILE.WATER){
          // warm plaster wall with bevel
          const g = ctx.createLinearGradient(px, py, px, py+TILE_SIZE);
          g.addColorStop(0, (((x+y)&1)===0) ? "#f2eee6" : "#ece6db");
          g.addColorStop(1, "#bfb3a2");
          ctx.fillStyle = g;
          ctx.fillRect(px,py,TILE_SIZE,TILE_SIZE);

          // subtle cracks
          ctx.strokeStyle = "rgba(80,60,40,0.12)";
          ctx.lineWidth = 1;
          if (((x*7+y*11)&7)===0){
            ctx.beginPath();
            ctx.moveTo(px+2, py+4);
            ctx.lineTo(px+TILE_SIZE-3, py+6);
            ctx.lineTo(px+TILE_SIZE-6, py+TILE_SIZE-4);
            ctx.stroke();
          }

          // bevel edges (3D)
          ctx.fillStyle = "rgba(255,255,255,0.20)";
          ctx.fillRect(px,py, TILE_SIZE,1);
          ctx.fillRect(px,py, 1,TILE_SIZE);
          ctx.fillStyle = "rgba(0,0,0,0.22)";
          ctx.fillRect(px,py+TILE_SIZE-1, TILE_SIZE,1);
          ctx.fillRect(px+TILE_SIZE-1,py, 1,TILE_SIZE);

          // tiny bolt occasionally
          if (((x*13+y*9)&31)===0){
            ctx.fillStyle = "rgba(0,0,0,0.25)";
            ctx.beginPath();
            ctx.arc(px+TILE_SIZE*0.3, py+TILE_SIZE*0.35, 1.2, 0, Math.PI*2);
            ctx.fill();
          }
          return;
        }
        // keep other tiles default (rare in level 4)
      }

// Level 3 tile shading: sandstone walls + crates + dust decals
      if (this.levelId===3){
        if (t===TILE.WATER){
          // Indestructible sandstone wall (uses WATER for collision)
          const baseTop = (((x+y)&1)===0) ? "#d9b97f" : "#d1ae74";
          const g = ctx.createLinearGradient(px, py, px, py+TILE_SIZE);
          g.addColorStop(0, baseTop);
          g.addColorStop(1, "#a77546");
          ctx.fillStyle = g;
          ctx.fillRect(px,py,TILE_SIZE,TILE_SIZE);

          // bevel
          ctx.fillStyle = "rgba(255,255,255,0.10)";
          ctx.fillRect(px+1,py+1,TILE_SIZE-2,1);
          ctx.fillRect(px+1,py+1,1,TILE_SIZE-2);
          ctx.fillStyle = "rgba(0,0,0,0.34)";
          ctx.fillRect(px+1,py+TILE_SIZE-2,TILE_SIZE-2,1);
          ctx.fillRect(px+TILE_SIZE-2,py+1,1,TILE_SIZE-2);

          // block lines
          ctx.strokeStyle = "rgba(0,0,0,0.14)";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(px+0.5, py+8.5); ctx.lineTo(px+TILE_SIZE-0.5, py+8.5);
          ctx.moveTo(px+8.5, py+0.5); ctx.lineTo(px+8.5, py+TILE_SIZE-0.5);
          ctx.stroke();

          // tiny pits
          if (((x*7 + y*13)&7)===0){
            ctx.fillStyle = "rgba(0,0,0,0.20)";
            ctx.fillRect(px+4, py+5, 2, 2);
            ctx.fillRect(px+10, py+11, 1, 1);
          }

          // soft edge glow
          if (((x+y)&3)===0){
            ctx.globalCompositeOperation = "lighter";
            ctx.strokeStyle = "rgba(255,230,185,0.09)";
            ctx.lineWidth = 1;
            ctx.strokeRect(px+0.5, py+0.5, TILE_SIZE-1, TILE_SIZE-1);
            ctx.globalCompositeOperation = "source-over";
          }
          return;
        }

        if (t===TILE.BRICK){
          // Breakable wooden crate / cover
          const g = ctx.createLinearGradient(px, py, px+TILE_SIZE, py+TILE_SIZE);
          g.addColorStop(0, "#d4a66b");
          g.addColorStop(1, "#7a4a28");
          ctx.fillStyle = g;
          ctx.fillRect(px,py,TILE_SIZE,TILE_SIZE);

          // plank lines
          ctx.strokeStyle = "rgba(0,0,0,0.22)";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(px+5.5, py+1); ctx.lineTo(px+5.5, py+TILE_SIZE-1);
          ctx.moveTo(px+10.5, py+1); ctx.lineTo(px+10.5, py+TILE_SIZE-1);
          ctx.stroke();

          // cross brace
          ctx.strokeStyle = "rgba(0,0,0,0.28)";
          ctx.beginPath();
          ctx.moveTo(px+2, py+2); ctx.lineTo(px+TILE_SIZE-2, py+TILE_SIZE-2);
          ctx.moveTo(px+TILE_SIZE-2, py+2); ctx.lineTo(px+2, py+TILE_SIZE-2);
          ctx.stroke();

          // highlight
          ctx.fillStyle = "rgba(255,255,255,0.10)";
          ctx.fillRect(px+1, py+1, TILE_SIZE-2, 1);

          // outline
          ctx.strokeStyle = "rgba(0,0,0,0.30)";
          ctx.strokeRect(px+0.5, py+0.5, TILE_SIZE-1, TILE_SIZE-1);
          return;
        }

        if (t===TILE.GRASS){
          // Dust decal (non-blocking)
          ctx.fillStyle = "rgba(122, 78, 38, 0.20)";
          ctx.fillRect(px,py,TILE_SIZE,TILE_SIZE);
          ctx.fillStyle = "rgba(60, 40, 20, 0.18)";
          const pts = this.grassDecor[this.idx(x,y)] || [];
          for (const p of pts) ctx.fillRect(px+p.x, py+p.y, p.r, p.r);
          ctx.globalAlpha = 0.10;
          ctx.fillStyle = "rgba(255,255,255,1)";
          ctx.fillRect(px+1, py+1, TILE_SIZE-2, 1);
          ctx.globalAlpha = 1;
          return;
        }
      }

      // Level 2 tile shading: more modern, beveled, higher contrast
      if (this.levelId===2){
        if (t===TILE.WATER){
          // Indestructible "steel wall" (uses WATER tile type for collision)
          const g = ctx.createLinearGradient(px, py, px, py+TILE_SIZE);
          g.addColorStop(0, "#2a3544");
          g.addColorStop(1, "#131a24");
          ctx.fillStyle = g;
          ctx.fillRect(px,py,TILE_SIZE,TILE_SIZE);

          // bevel
          ctx.fillStyle = "rgba(255,255,255,0.10)";
          ctx.fillRect(px+1,py+1,TILE_SIZE-2,1);
          ctx.fillRect(px+1,py+1,1,TILE_SIZE-2);
          ctx.fillStyle = "rgba(0,0,0,0.40)";
          ctx.fillRect(px+1,py+TILE_SIZE-2,TILE_SIZE-2,1);
          ctx.fillRect(px+TILE_SIZE-2,py+1,1,TILE_SIZE-2);

          // panel lines
          ctx.fillStyle = "rgba(255,255,255,0.04)";
          ctx.fillRect(px+3, py+5, TILE_SIZE-6, 1);
          ctx.fillRect(px+3, py+10, TILE_SIZE-6, 1);

          // bolts
          ctx.fillStyle = "rgba(0,0,0,0.35)";
          const b = 2.6;
          ctx.beginPath(); ctx.arc(px+3, py+3, b, 0, Math.PI*2); ctx.fill();
          ctx.beginPath(); ctx.arc(px+TILE_SIZE-3, py+3, b, 0, Math.PI*2); ctx.fill();
          ctx.beginPath(); ctx.arc(px+3, py+TILE_SIZE-3, b, 0, Math.PI*2); ctx.fill();
          ctx.beginPath(); ctx.arc(px+TILE_SIZE-3, py+TILE_SIZE-3, b, 0, Math.PI*2); ctx.fill();

          // subtle edge glow
          if (((x+y)&3)===0){
            ctx.globalCompositeOperation = "lighter";
            ctx.strokeStyle = "rgba(120,200,255,0.10)";
            ctx.lineWidth = 1;
            ctx.strokeRect(px+0.5, py+0.5, TILE_SIZE-1, TILE_SIZE-1);
            ctx.globalCompositeOperation = "source-over";
          }
          return;
        }

        if (t===TILE.BRICK){
          // Breakable cover (warmer, "crate" feel)
          const g = ctx.createLinearGradient(px, py, px+TILE_SIZE, py+TILE_SIZE);
          g.addColorStop(0, "#c35e33");
          g.addColorStop(1, "#6f2b1c");
          ctx.fillStyle = g;
          ctx.fillRect(px,py,TILE_SIZE,TILE_SIZE);

          // ribs
          ctx.fillStyle = "rgba(255,255,255,0.08)";
          ctx.fillRect(px+2, py+3, TILE_SIZE-4, 2);
          ctx.fillRect(px+2, py+TILE_SIZE-5, TILE_SIZE-4, 2);

          // cracks/scratches
          ctx.strokeStyle = "rgba(0,0,0,0.35)";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(px+4, py+6); ctx.lineTo(px+10, py+4);
          ctx.moveTo(px+6, py+12); ctx.lineTo(px+12, py+9);
          ctx.stroke();

          // edge
          ctx.strokeStyle = "rgba(0,0,0,0.25)";
          ctx.strokeRect(px+0.5, py+0.5, TILE_SIZE-1, TILE_SIZE-1);
          return;
        }

        if (t===TILE.GRASS){
          // Slightly richer grass for level 2
          ctx.fillStyle = "rgba(46, 178, 92, 0.78)";
          ctx.fillRect(px,py,TILE_SIZE,TILE_SIZE);
          ctx.fillStyle = "rgba(18, 92, 44, 0.62)";
          const pts = this.grassDecor[this.idx(x,y)] || [];
          for (const p of pts) ctx.fillRect(px+p.x, py+p.y, p.r, p.r);
          ctx.globalAlpha = 0.20;
          ctx.fillStyle = "rgba(255,255,255,1)";
          ctx.fillRect(px+1, py+1, TILE_SIZE-2, 1);
          ctx.globalAlpha = 1;
          return;
        }
      }

      if (t===TILE.BRICK){
        ctx.fillStyle = "#8c3b2f";
        ctx.fillRect(px,py,TILE_SIZE,TILE_SIZE);

        ctx.fillStyle = "#b4513b";
        for (let i=0;i<4;i++){
          ctx.fillRect(px+1, py+1+i*4, TILE_SIZE-2, 2);
        }

        ctx.fillStyle = "rgba(255,255,255,0.07)";
        ctx.fillRect(px+1, py+1, TILE_SIZE-2, 1);
        ctx.fillStyle = "rgba(0,0,0,0.32)";
        ctx.fillRect(px, py+TILE_SIZE-1, TILE_SIZE, 1);
        ctx.fillRect(px+TILE_SIZE-1, py, 1, TILE_SIZE);

      } else if (t===TILE.WATER){
        ctx.fillStyle = "#1e4b9b";
        ctx.fillRect(px,py,TILE_SIZE,TILE_SIZE);
        const w = Math.sin(tSec*4 + (x+y)*0.7) * 0.5 + 0.5;
        ctx.fillStyle = `rgba(255,255,255,${0.08 + w*0.08})`;
        ctx.fillRect(px+2,py+3,4,2);
        ctx.fillRect(px+9,py+9,5,2);
        ctx.fillRect(px+4,py+11,3,2);
        ctx.fillStyle = "rgba(0,0,0,0.25)";
        ctx.fillRect(px, py+TILE_SIZE-1, TILE_SIZE, 1);

      } else if (t===TILE.GRASS){
        ctx.fillStyle = "rgba(42, 160, 80, 0.76)";
        ctx.fillRect(px,py,TILE_SIZE,TILE_SIZE);
        ctx.fillStyle = "rgba(18, 88, 42, 0.62)";
        const pts = this.grassDecor[this.idx(x,y)] || [];
        for (const p of pts) ctx.fillRect(px+p.x, py+p.y, p.r, p.r);
        ctx.globalAlpha = 0.22;
        ctx.fillStyle = "rgba(255,255,255,1)";
        ctx.fillRect(px+1, py+1, TILE_SIZE-2, 1);
        ctx.globalAlpha = 1;
      }
    }
  }

  class Bullet {
    constructor(owner, x, y, vx, vy, target=null) {
      this.owner = owner;
      this.x=x; this.y=y;
      this.vx=vx; this.vy=vy;
      this.speed = 300;
      this.r = 2;
      this.alive = true;
      this.tx = x;
      this.ty = y;

      // Aim-assist: player bullets can softly home towards a locked target
      this.target = target;
      this.homing = (owner === "player") && !!target;
    }

    update(dt, map, tanks, audio, fx) {
      if (!this.alive) return;

      // Soft homing (helps guarantee hit while keeping bullets physical)
      if (this.homing && this.target && this.target.alive){
        const cx = this.x, cy = this.y;
        const tx = this.target.x + this.target.w/2;
        const ty = this.target.y + this.target.h/2;
        const dx = tx - cx, dy = ty - cy;
        const d = Math.hypot(dx,dy);
        if (d > 0.001){
          const dvx = dx / d, dvy = dy / d;
          // Smoothly steer towards desired direction
          const steer = 1 - Math.pow(0.05, dt);
          this.vx = lerp(this.vx, dvx, steer);
          this.vy = lerp(this.vy, dvy, steer);
          const m = Math.hypot(this.vx, this.vy) || 1;
          this.vx /= m; this.vy /= m;
        }
      }

      this.tx = this.x; this.ty = this.y;
      this.x += this.vx*this.speed*dt;
      this.y += this.vy*this.speed*dt;

      if (this.x<0||this.y<0||this.x>CANVAS_SIZE||this.y>CANVAS_SIZE){ this.alive=false; return; }

      const hit = map.bulletHit(this.x, this.y);
      if (hit.stop) {
        this.alive = false;
        audio?.sfxHit();
        const cx = (hit.tx + 0.5) * TILE_SIZE;
        const cy = (hit.ty + 0.5) * TILE_SIZE;
        fx?.burstBrick(cx, cy);
        return;
      }

      for (const t of tanks) {
        if (!t.alive) continue;
        if (t.faction === this.owner) continue;
        const bx=this.x-this.r, by=this.y-this.r, bw=this.r*2, bh=this.r*2;
        if (rectsIntersect(bx,by,bw,bh, t.x,t.y,t.w,t.h)) {
          // Damage model: player has higher HP; enemies default to 1 HP
          t.hp = Math.max(0, (t.hp|0) - 1);
          t.hitFlash = 1;

          this.alive = false;

          if (t.hp <= 0){
            t.alive = false;
            audio?.sfxBoom();
            fx?.burstTank(t.x + t.w/2, t.y + t.h/2);
          } else {
            if (t.faction === "player") audio?.sfxPlayerHit();
            else audio?.sfxHit();
          }
          return;
        }
      }
    }

    draw(ctx) {
      if (!this.alive) return;

      const col = (this.owner==="player") ? "rgba(246,224,94,1)" : "rgba(255,107,107,1)";

      // tracer + glow (modern punch)
      ctx.save();
      ctx.globalCompositeOperation = "lighter";

      const grad = ctx.createLinearGradient(this.tx, this.ty, this.x, this.y);
      grad.addColorStop(0, "rgba(255,255,255,0)");
      grad.addColorStop(0.35, col.replace("1)", "0.25)"));
      grad.addColorStop(1, col.replace("1)", "0.85)"));

      ctx.strokeStyle = grad;
      ctx.lineWidth = 3.2;
      ctx.lineCap = "round";
      ctx.shadowColor = col;
      ctx.shadowBlur = 14;
      ctx.beginPath();
      ctx.moveTo(this.tx, this.ty);
      ctx.lineTo(this.x, this.y);
      ctx.stroke();

      // core
      ctx.shadowBlur = 18;
      ctx.globalAlpha = 0.95;
      ctx.fillStyle = col;
      ctx.beginPath();
      ctx.arc(this.x, this.y, 3.2, 0, Math.PI*2);
      ctx.fill();

      // hot center
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 0.7;
      ctx.fillStyle = "rgba(255,255,255,1)";
      ctx.beginPath();
      ctx.arc(this.x, this.y, 1.4, 0, Math.PI*2);
      ctx.fill();

      ctx.restore();

    }
  }

  class Tank {
    constructor(faction, x, y, color) {
      this.faction=faction;
      this.x=x; this.y=y;
      this.w=14; this.h=14;
      this.angle=-Math.PI/2;
      this.targetAngle=this.angle;
      this.speed=110;
      this.color=color;
      this.alive=true;

      // Health
      this.maxHp = 1;
      this.hp = this.maxHp;

      this.fireCooldown=0;
      this.fireRate=0.38;
      this.hitFlash=0;
    }

    update(dt){
      if (this.fireCooldown>0) this.fireCooldown -= dt;
      this.angle = angleLerp(this.angle, this.targetAngle, 1 - Math.pow(0.001, dt));
      this.hitFlash = Math.max(0, this.hitFlash - dt*4);
    }

    canFire(){ return this.fireCooldown<=0; }

    
fire(bullets, audio, fx){
      if (!this.canFire() || !this.alive) return;
      this.fireCooldown = this.fireRate;
      const cx=this.x+this.w/2, cy=this.y+this.h/2;
      const vx=Math.cos(this.angle), vy=Math.sin(this.angle);
      const off=10;
      bullets.push(new Bullet(this.faction, cx+vx*off, cy+vy*off, vx, vy));
      audio?.sfxShoot();
      fx?.muzzleFlash(cx+vx*(off+2), cy+vy*(off+2), this.angle, this.faction);
    }tryMove(dt, map, vx, vy){
      const nx=this.x + vx*this.speed*dt;
      if (!map.collidesRect(nx, this.y, this.w, this.h)) this.x = nx;
      const ny=this.y + vy*this.speed*dt;
      if (!map.collidesRect(this.x, ny, this.w, this.h)) this.y = ny;
      this.x = clamp(this.x, 1, CANVAS_SIZE - this.w - 1);
      this.y = clamp(this.y, 1, CANVAS_SIZE - this.h - 1);
    }

    draw(ctx){
      if (!this.alive) return;
      const cx=this.x+this.w/2, cy=this.y+this.h/2;

      const base = this.color;
      const cLight = lighten(base, 0.26);
      const cMid = base;
      const cDark = darken(base, 0.38);

      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(this.angle);

      // ground shadow (elliptical)
      ctx.save();
      ctx.globalAlpha = 0.35;
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.scale(1.05, 0.75);
      ctx.beginPath();
      ctx.arc(0, 4.2, this.w*0.58, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

      const bw = this.w, bh = this.h;
      const r = 3.6;

      // tracks
      const trackW = 3.4;
      ctx.fillStyle = "rgba(7,10,16,0.85)";
      rrPath(ctx, -bw/2-0.2, -bh/2+0.8, trackW, bh-1.6, 1.4); ctx.fill();
      rrPath(ctx,  bw/2-trackW+0.2, -bh/2+0.8, trackW, bh-1.6, 1.4); ctx.fill();

      // tread notches
      ctx.globalAlpha = 0.18;
      ctx.fillStyle = "rgba(255,255,255,1)";
      for (let i=-5; i<=5; i+=3){
        ctx.fillRect(-bw/2+0.7, i, 1.2, 1.2);
        ctx.fillRect( bw/2-1.9, i, 1.2, 1.2);
      }
      ctx.globalAlpha = 1;

      // chassis
      const g = ctx.createLinearGradient(-bw/2, -bh/2, bw/2, bh/2);
      g.addColorStop(0, cLight);
      g.addColorStop(0.55, cMid);
      g.addColorStop(1, cDark);

      ctx.shadowColor = "rgba(0,0,0,0.45)";
      ctx.shadowBlur = 10;
      ctx.shadowOffsetY = 2;
      ctx.fillStyle = g;
      rrPath(ctx, -bw/2+1.2, -bh/2, bw-2.4, bh, r);
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.shadowOffsetY = 0;

      // subtle top highlight
      ctx.globalAlpha = 0.22;
      ctx.fillStyle = "rgba(255,255,255,1)";
      rrPath(ctx, -bw/2+2.0, -bh/2+1.0, bw-4.0, 3.0, 2.0);
      ctx.fill();
      ctx.globalAlpha = 1;

      // turret base
      ctx.fillStyle = cMid;
      ctx.beginPath();
      ctx.arc(0, 0, 5.2, 0, Math.PI*2);
      ctx.fill();

      const tg = ctx.createRadialGradient(-2, -2, 1, 0, 0, 7);
      tg.addColorStop(0, "rgba(255,255,255,0.22)");
      tg.addColorStop(1, "rgba(0,0,0,0.28)");
      ctx.fillStyle = tg;
      ctx.beginPath();
      ctx.arc(0, 0, 5.2, 0, Math.PI*2);
      ctx.fill();

      // barrel
      const bg = ctx.createLinearGradient(0, -2, 14, 2);
      bg.addColorStop(0, "rgba(12,16,28,0.98)");
      bg.addColorStop(1, "rgba(0,0,0,0.55)");
      ctx.fillStyle = bg;
      rrPath(ctx, 2.6, -1.7, 12.0, 3.4, 1.5);
      ctx.fill();

      // barrel tip shine
      ctx.fillStyle = "rgba(255,255,255,0.16)";
      rrPath(ctx, 13.0, -1.3, 2.0, 2.6, 1.0);
      ctx.fill();

      // outline
      ctx.strokeStyle = "rgba(0,0,0,0.40)";
      ctx.lineWidth = 1.2;
      rrPath(ctx, -bw/2+1.2, -bh/2, bw-2.4, bh, r);
      ctx.stroke();
      ctx.beginPath(); ctx.arc(0,0,5.2,0,Math.PI*2); ctx.stroke();

      // hit flash
      if (this.hitFlash > 0) {
        ctx.globalCompositeOperation = "lighter";
        ctx.globalAlpha = 0.32 * this.hitFlash;
        ctx.fillStyle = "rgba(255,255,255,1)";
        rrPath(ctx, -bw/2+1.2, -bh/2, bw-2.4, bh, r);
        ctx.fill();
        ctx.beginPath(); ctx.arc(0,0,5.2,0,Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = "source-over";
      }

      ctx.restore();
    }
  }

  class Player extends Tank {
    constructor(x,y){
      super("player", x,y, "#4ade80");
      this.speed=135;
      this.fireRate=0.31;
      this.maxHp = PLAYER_MAX_HP;
      this.hp = this.maxHp;
    }

    
fire(bullets, audio, aimTarget, fx){
      if (!this.canFire() || !this.alive) return;

      // If aim-assist target exists, shoot towards it (with a homing bullet for "press to hit" feel)
      let vx = Math.cos(this.angle), vy = Math.sin(this.angle);
      let target = null;

      if (aimTarget && aimTarget.alive){
        const cx=this.x+this.w/2, cy=this.y+this.h/2;
        const tx=aimTarget.x + aimTarget.w/2;
        const ty=aimTarget.y + aimTarget.h/2;
        const dx = tx - cx, dy = ty - cy;
        const d = Math.hypot(dx,dy);
        if (d > 0.001 && (dx*dx + dy*dy) <= VISION_RADIUS_SQ){
          vx = dx / d;
          vy = dy / d;
          const a = Math.atan2(vy, vx);
          this.targetAngle = a;
          this.angle = a;
          target = aimTarget;
        }
      }

      this.fireCooldown = this.fireRate;
      const cx=this.x+this.w/2, cy=this.y+this.h/2;
      const off=10;
      bullets.push(new Bullet(this.faction, cx+vx*off, cy+vy*off, vx, vy, target));
      audio?.sfxShoot();

      fx?.muzzleFlash(cx+vx*(off+2), cy+vy*(off+2), Math.atan2(vy, vx), this.faction);
    }handleInput(dt, map, input, bullets, audio, aimTarget, fx){
      if (!this.alive) return;

      let vx=input.axisX, vy=input.axisY;
      const mag=Math.hypot(vx,vy);

      if (mag>0.001){
        vx/=mag; vy/=mag;
        this.targetAngle = Math.atan2(vy, vx);
        this.tryMove(dt, map, vx, vy);
      } else if (aimTarget && aimTarget.alive){
        // When standing still, auto-face the locked target to make it feel assisted.
        const cx=this.x+this.w/2, cy=this.y+this.h/2;
        const tx=aimTarget.x + aimTarget.w/2;
        const ty=aimTarget.y + aimTarget.h/2;
        const dx = tx - cx, dy = ty - cy;
        if ((dx*dx + dy*dy) <= VISION_RADIUS_SQ){
          this.targetAngle = Math.atan2(dy, dx);
        }
      }

      if (input.firePressed) this.fire(bullets, audio, aimTarget, fx);
    }
  }

  class Enemy extends Tank {
    constructor(x,y){
      super("enemy", x,y, "#60a5fa");
      this.speed=100;
      this.fireRate=0.56;
      this.aiTimer=0;
      this.changeInterval=0.55+Math.random()*0.9;
      this.moveAngle=Math.PI/2;
    }
    updateAI(dt, map, player, bullets, audio, fx){
      if (!this.alive) return;
      this.update(dt);

      // AI sight check (cannot 'see' player outside the vision radius)
      const dx0 = player.x - this.x;
      const dy0 = player.y - this.y;
      const canSee = (dx0*dx0 + dy0*dy0) <= VISION_RADIUS_SQ;

      this.aiTimer += dt;
      if (this.aiTimer > this.changeInterval){
        this.aiTimer=0;
        this.changeInterval=0.55+Math.random()*0.9;
        if (Math.random()<0.62 && canSee){
          const dx=player.x-this.x, dy=player.y-this.y;
          this.moveAngle = Math.atan2(dy, dx) + rand(-0.35, 0.35);
        } else {
          this.moveAngle = Math.random()*Math.PI*2;
        }
      }

      const vx=Math.cos(this.moveAngle), vy=Math.sin(this.moveAngle);
      const ox=this.x, oy=this.y;
      this.tryMove(dt, map, vx, vy);
      const moved=(Math.abs(this.x-ox)+Math.abs(this.y-oy))>0.01;
      if (!moved) this.moveAngle += (Math.random()<0.5?1:-1) * (Math.PI/2);

      this.targetAngle = this.moveAngle;

      const dx=player.x-this.x, dy=player.y-this.y;
      const toP = Math.atan2(dy, dx);
      const diff = Math.abs(((toP - this.angle + Math.PI)%(Math.PI*2))-Math.PI);
      let p=0.007;
      if (diff<0.35) p=0.03;

      if (canSee && this.canFire() && Math.random() < p*(dt*60)){
        this.targetAngle = toP;
        this.angle = angleLerp(this.angle, this.targetAngle, 0.8);
        this.fire(bullets, audio, fx);
      }
    }
  }

  class Input {
    constructor(){
      this.axisX = 0;
      this.axisY = 0;
      this._k = {left:false,right:false,up:false,down:false};
      this.firePressed = false;
      this._fireDown = false;
      this.restartPressed = false;

      window.addEventListener("keydown", (e)=>this.onKey(e,true), {passive:false});
      window.addEventListener("keyup", (e)=>this.onKey(e,false), {passive:false});
      // Avoid stuck keys when tab loses focus
      window.addEventListener("blur", ()=>{
        this._k = {left:false,right:false,up:false,down:false};
        this._fireDown = false;
        this.firePressed = false;
      });
    }
    onKey(e,down){
      const k=e.code;
      if ([
        "ArrowLeft","ArrowRight","ArrowUp","ArrowDown",
        "KeyW","KeyA","KeyS","KeyD",
        "Space","KeyR"
      ].includes(k)) e.preventDefault();

      // Movement: Arrow keys (primary) + WASD (secondary)
      if (k==="ArrowLeft" || k==="KeyA") this._k.left=down;
      if (k==="ArrowRight" || k==="KeyD") this._k.right=down;
      if (k==="ArrowUp" || k==="KeyW") this._k.up=down;
      if (k==="ArrowDown" || k==="KeyS") this._k.down=down;

      // Fire: Space as backup (mouse left click handled on canvas)
      if (k==="Space"){
        if (down && !this._fireDown) this.firePressed=true;
        this._fireDown=down;
      }

      if (k==="KeyR"){ if (down) this.restartPressed=true; }
    }
    setFirePressed(){ this.firePressed=true; }
    setFireDown(down){
      if (down && !this._fireDown) this.firePressed = true;
      this._fireDown = !!down;
    }
    setDir(dir, down){
      const v = !!down;
      if (dir==="left") this._k.left = v;
      else if (dir==="right") this._k.right = v;
      else if (dir==="up") this._k.up = v;
      else if (dir==="down") this._k.down = v;
    }
    update(_dt){
      let ax=0, ay=0;
      if (this._k.left) ax-=1;
      if (this._k.right) ax+=1;
      if (this._k.up) ay-=1;
      if (this._k.down) ay+=1;
      const mag = Math.hypot(ax,ay);
      if (mag>1){ ax/=mag; ay/=mag; }
      this.axisX=ax; this.axisY=ay;
    }
    endFrame(){ this.firePressed=false; this.restartPressed=false; }
  }

  class Game {
    constructor(canvas){
      this.canvas=canvas;
      this.ctx=canvas.getContext("2d");
      this.ctx.imageSmoothingEnabled=false;

      
      // Cache expensive gradients/patterns (perf + avoid GPU flicker on some drivers)
      this.vignette = this.ctx.createRadialGradient(CANVAS_SIZE/2, CANVAS_SIZE/2, 90, CANVAS_SIZE/2, CANVAS_SIZE/2, 380);
      this.vignette.addColorStop(0, "rgba(0,0,0,0)");
      this.vignette.addColorStop(1, "rgba(0,0,0,0.32)");
      // ç§»é™¤æ‰«æçº¿æ•ˆæœï¼ˆä¼šåœ¨éƒ¨åˆ†æ˜¾ç¤ºå™¨/ç¼©æ”¾ä¸‹äº§ç”Ÿä¸€æ¡æ˜æ˜¾çš„é«˜äº®æ¨ªçº¿ï¼‰
      this.scanAlpha = 0;
      this.levelId = parseInt(localStorage.getItem("tank_level") || "1", 10);
      if (this.levelId !== 2 && this.levelId !== 3) this.levelId = 1;
      this.map = new TileMap(GRID, GRID, this.levelId);
      this.input = new Input();

      this.paused = false;
      window.addEventListener("keydown", (e)=>{
        if (e.code==="KeyP" || e.code==="Escape"){
          e.preventDefault();
          this.togglePause();
        }
      }, {passive:false});

      // PC controls: mouse left-click fires (avoid touch to not interfere with mobile)
      this.canvas.addEventListener("pointerdown", (e)=>{
        if (e.pointerType==="mouse" && e.button===0) this.input.setFirePressed();
      }, {passive:true});
      this.canvas.addEventListener("contextmenu", (e)=>e.preventDefault());
      this.audio = new AudioManager();
      this.fx = new FX();

      this.scoreEl = document.getElementById("score");
      this.enemiesEl = document.getElementById("enemies");
      this.statusEl = document.getElementById("status");
      this.hpEl = document.getElementById("hp");
      this.hpMaxEl = document.getElementById("hpMax");

      this.tSec = 0;
      this.reset();

      this.lastTs = performance.now();
      requestAnimationFrame((t)=>this.loop(t));
    }

    getSpawnPoints(){
      // Level 1/2: classic spawns; Level 3: larger safe spawn rooms
      if (this.levelId===3){
        return {
          player: { x: 2*TILE_SIZE + 1, y: (GRID-4)*TILE_SIZE + 1 },
          enemy:  { x: (GRID-4)*TILE_SIZE + 1, y: 2*TILE_SIZE + 1 },
        };
      }
      return {
        player: { x: 1*TILE_SIZE + 1, y: (GRID-3)*TILE_SIZE + 1 },
        enemy:  { x: (GRID-3)*TILE_SIZE + 1, y: 1*TILE_SIZE + 1 },
      };
    }

    reset(){
      this.map.reset(this.levelId);
      const sp = this.getSpawnPoints();
      this.player = new Player(sp.player.x, sp.player.y);
      this.bullets = [];
      this.enemies = [];
      this.spawnTimer = 0;
      this.spawnInterval = (this.levelId===2 ? 1.05 : (this.levelId===4 ? 1.10 : (this.levelId===3 ? 1.18 : 1.35)));
      this.maxEnemies = (this.levelId===2 ? 6 : (this.levelId===4 ? 6 : (this.levelId===3 ? 5 : 4)));
      this.score=0;
      this.gameOver=false;
      this.paused=false;
      // Aim-assist (auto lock nearest enemy in sight every 2s)
      this.aimLockInterval = 2.0;
      this.aimLockTimer = 999;
      this.aimTarget = null;
      // Killstreak (10s window)
      this.killStreak = 0;
      this.lastKillAt = -1e9;
      this.killWindow = 10.0;
      this.updateHUD();
      if (typeof this.onPauseChange === "function") this.onPauseChange(this.paused);
    }

    togglePause(){
      if (this.gameOver) return;
      this.paused = !this.paused;
      // Clear one-frame inputs soæ¢å¤æ—¶ä¸ä¼šè¯¯è§¦
      this.input.firePressed = false;
      this.input.restartPressed = false;
      this.updateHUD();
      if (typeof this.onPauseChange === "function") this.onPauseChange(this.paused);
    }


    setLevel(id){
      const n = parseInt(id, 10);
      const lv = (n===2 || n===3 || n===4) ? n : 1;
      if (lv === this.levelId) return;
      this.levelId = lv;
      try { localStorage.setItem("tank_level", String(lv)); } catch(_){}
      this.reset();
      if (typeof this.onLevelChange === "function") this.onLevelChange(lv);
    }


    onEnemyKilled(){
      // 10s combo window: reset to 1 if timeout; otherwise increment (cap 5)
      const now = this.tSec;
      if (now - this.lastKillAt <= this.killWindow) this.killStreak = Math.min(5, this.killStreak + 1);
      else this.killStreak = 1;
      this.lastKillAt = now;
      if (this.audio) this.audio.playKillCallout(this.killStreak);
    }

updateHUD(){
      this.scoreEl.textContent = String(this.score);
      this.enemiesEl.textContent = String(this.enemies.filter(e=>e.alive).length);
      this.statusEl.textContent = this.gameOver ? "å¤±è´¥" : (this.paused ? "æš‚åœ" : "è¿è¡Œä¸­");
      if (this.player){
        this.hpEl.textContent = String(Math.max(0, this.player.hp|0));
        this.hpMaxEl.textContent = String(this.player.maxHp|0);
      }
    }

    spawnEnemy(){
      const sp = this.getSpawnPoints();
      const e = new Enemy(sp.enemy.x, sp.enemy.y);
      e.angle = Math.PI/2;
      e.targetAngle = e.angle;
      this.enemies.push(e);
    }


    updateAimAssist(dt){
      // Auto-lock the nearest visible enemy inside the vision circle.
      // Re-lock every `aimLockInterval` seconds (won't constantly switch targets).
      this.aimLockTimer += dt;
      if (this.aimLockTimer < this.aimLockInterval) return;
      this.aimLockTimer = 0;

      const pcx = this.player.x + this.player.w/2;
      const pcy = this.player.y + this.player.h/2;

      let best = null;
      let bestD2 = Infinity;

      for (const e of this.enemies){
        if (!e.alive) continue;
        const ecx = e.x + e.w/2;
        const ecy = e.y + e.h/2;
        const dx = ecx - pcx;
        const dy = ecy - pcy;
        const d2 = dx*dx + dy*dy;
        if (d2 > VISION_RADIUS_SQ) continue;
        if (!this._lineOfSight(pcx, pcy, ecx, ecy)) continue;
        if (d2 < bestD2){
          bestD2 = d2;
          best = e;
        }
      }

      this.aimTarget = best;
    }

    _lineOfSight(ax, ay, bx, by){
      // Sample along the segment and check solid tiles (brick/water).
      // TileMap.get() returns BRICK for out-of-bounds, so this also prevents locking through edges.
      const dx = bx - ax;
      const dy = by - ay;
      const dist = Math.hypot(dx, dy);
      const steps = Math.max(1, Math.ceil(dist / (TILE_SIZE/3)));
      for (let i=1; i<steps; i++){
        const t = i / steps;
        const x = ax + dx * t;
        const y = ay + dy * t;
        const tx = Math.floor(x / TILE_SIZE);
        const ty = Math.floor(y / TILE_SIZE);
        if (this.map.isSolid(this.map.get(tx, ty))) return false;
      }
      return true;
    }

    loop(ts){
      const dt = clamp((ts - this.lastTs)/1000, 0, 0.05);
      this.lastTs = ts;
      if (this.input.restartPressed) {
        this.paused = false;
        this.reset();
      }
      if (!this.paused){
        this.tSec += dt;
        this.update(dt);
      }
      this.render();
      this.input.endFrame();
      requestAnimationFrame((t)=>this.loop(t));
    }

    update(dt){
      this.input.update(dt);
      this.fx.update(dt);

      if (this.input.restartPressed) { this.reset(); return; }
      if (this.gameOver) return;

      this.spawnTimer += dt;
      const alive = this.enemies.filter(e=>e.alive);
      if (this.spawnTimer >= this.spawnInterval && alive.length < this.maxEnemies){
        this.spawnTimer = 0;
        this.spawnEnemy();
      }

      this.player.update(dt);
      this.updateAimAssist(dt);
      this.player.handleInput(dt, this.map, this.input, this.bullets, this.audio, this.aimTarget, this.fx);

      for (const e of this.enemies) e.updateAI(dt, this.map, this.player, this.bullets, this.audio, this.fx);

      const tanks = [this.player, ...this.enemies];
      for (const b of this.bullets) b.update(dt, this.map, tanks, this.audio, this.fx);
      this.bullets = this.bullets.filter(b=>b.alive);

      for (const e of this.enemies){
        if (!e._counted && !e.alive){
          e._counted = true;
          this.score += 120;
          this.onEnemyKilled();
        }
      }
      this.enemies = this.enemies.filter(e => e.alive || (e._counted && Math.random() < 0.997));

      if (!this.player.alive){
        this.gameOver = true;
        this.fx.burstTank(this.player.x + this.player.w/2, this.player.y + this.player.h/2);
      }

      this.updateHUD();
    }

    render(){
      const ctx=this.ctx;
      ctx.save();
      ctx.translate(this.fx.shakeX, this.fx.shakeY);

      this.map.draw(ctx, this.tSec);

      const pcx = this.player.x + this.player.w/2;
      const pcy = this.player.y + this.player.h/2;

      this.player.draw(ctx);
      for (const e of this.enemies){
        if (!e.alive) continue;
        const ecx = e.x + e.w/2;
        const ecy = e.y + e.h/2;
        const dx = ecx - pcx;
        const dy = ecy - pcy;
        if (dx*dx + dy*dy <= VISION_RADIUS_SQ) e.draw(ctx);
      }


// Aim-assist reticle: show where the auto-lock is (within vision range)
if (this.aimTarget && this.aimTarget.alive){
  const ecx = this.aimTarget.x + this.aimTarget.w/2;
  const ecy = this.aimTarget.y + this.aimTarget.h/2;
  const dx = ecx - pcx;
  const dy = ecy - pcy;
  if (dx*dx + dy*dy <= VISION_RADIUS_SQ){
    const pulse = 0.5 + 0.5*Math.sin(this.tSec*5.2);
    const r = 7.5 + pulse*0.8;

    ctx.save();
    ctx.translate(ecx, ecy);
    ctx.globalCompositeOperation = "lighter";
    ctx.rotate(this.tSec*0.9);

    // soft glow ring
    ctx.globalAlpha = 0.55;
    ctx.strokeStyle = `rgba(255,90,90,${0.12 + pulse*0.10})`;
    ctx.lineWidth = 10;
    ctx.beginPath();
    ctx.arc(0, 0, r, 0, Math.PI*2);
    ctx.stroke();

    // crisp ring
    ctx.globalAlpha = 1;
    ctx.strokeStyle = "rgba(255,255,255,0.88)";
    ctx.lineWidth = 2;
    ctx.shadowColor = "rgba(255,90,90,1)";
    ctx.shadowBlur = 12;
    ctx.beginPath();
    ctx.arc(0, 0, r, 0, Math.PI*2);
    ctx.stroke();
    ctx.shadowBlur = 0;

    // ticks
    ctx.strokeStyle = "rgba(255,90,90,0.98)";
    ctx.lineWidth = 1.8;
    ctx.beginPath();
    ctx.moveTo(-r-4, 0); ctx.lineTo(-r+1, 0);
    ctx.moveTo( r-1, 0); ctx.lineTo( r+4, 0);
    ctx.moveTo(0, -r-4); ctx.lineTo(0, -r+1);
    ctx.moveTo(0,  r-1); ctx.lineTo(0,  r+4);
    ctx.stroke();

    ctx.globalCompositeOperation = "source-over";
    ctx.restore();
  }
}

for (const b of this.bullets) b.draw(ctx);

// Ambient spotlight: makes the scene feel deeper and more modern
ctx.save();
const fog = ctx.createRadialGradient(pcx, pcy, VISION_RADIUS*0.35, pcx, pcy, VISION_RADIUS*1.85);
fog.addColorStop(0, "rgba(0,0,0,0)");
fog.addColorStop(1, "rgba(0,0,0,0.42)");
ctx.fillStyle = fog;
ctx.fillRect(0,0,CANVAS_SIZE,CANVAS_SIZE);
ctx.restore();

// Vision circle (helps players feel the sight range)
      ctx.save();
      ctx.globalAlpha = 0.55;
      ctx.strokeStyle = "rgba(255,255,255,0.16)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(pcx, pcy, VISION_RADIUS, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();

      this.map.drawGrassOverlay(ctx);
      this.fx.draw(ctx);

      ctx.fillStyle = this.vignette;
      ctx.fillRect(0,0,CANVAS_SIZE,CANVAS_SIZE);

      // (å·²ç§»é™¤) æ‰«æçº¿æ•ˆæœ

      if (this.fx.flash > 0) {
        ctx.globalAlpha = 0.28 * this.fx.flash;
        ctx.fillStyle = "rgba(255,255,255,1)";
        ctx.fillRect(0,0,CANVAS_SIZE,CANVAS_SIZE);
        ctx.globalAlpha = 1;
      }

      if (this.gameOver){
        ctx.fillStyle = "rgba(0,0,0,0.55)";
        ctx.fillRect(0,0,CANVAS_SIZE,CANVAS_SIZE);
        ctx.fillStyle = "#ffffff";
        ctx.font = "900 30px system-ui, sans-serif";
        ctx.textAlign="center";
        ctx.fillText("æ¸¸æˆå¤±è´¥", CANVAS_SIZE/2, CANVAS_SIZE/2 - 10);
        ctx.font = "14px system-ui, sans-serif";
        ctx.fillStyle = "rgba(255,255,255,0.9)";
        ctx.fillText("æŒ‰ R æˆ– ç‚¹å‡»é‡å¼€", CANVAS_SIZE/2, CANVAS_SIZE/2 + 22);
      }

      if (!this.gameOver && this.paused){
        ctx.fillStyle = "rgba(0,0,0,0.45)";
        ctx.fillRect(0,0,CANVAS_SIZE,CANVAS_SIZE);
        ctx.fillStyle = "rgba(255,255,255,0.92)";
        ctx.font = "900 22px system-ui, sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("å·²æš‚åœ", CANVAS_SIZE/2, CANVAS_SIZE/2 - 6);
        ctx.font = "14px system-ui, sans-serif";
        ctx.fillStyle = "rgba(255,255,255,0.78)";
        ctx.fillText("æŒ‰ P / Esc ç»§ç»­", CANVAS_SIZE/2, CANVAS_SIZE/2 + 18);
      }

      ctx.restore();
    }
  }

  const canvas = document.getElementById("game");
  game = new Game(canvas);

  // Mobile touch controls (D-pad + fire + pause). Shown only on touch devices.
  (function setupTouchControls(){
    const isTouch = (navigator.maxTouchPoints && navigator.maxTouchPoints > 0) || ("ontouchstart" in window);
    const bar = document.getElementById("touchBar");
    if (!bar || !isTouch) return;

    const bindHold = (el, onDown, onUp)=>{
      if (!el) return;

      let activePointerId = null;
      let activeTouch = false;

      const down = (e)=>{
        if (e && e.pointerType === "mouse") return;
        try{ e && e.preventDefault(); }catch{}
        if (activePointerId !== null || activeTouch) return;

        if (e && typeof e.pointerId === "number"){
          activePointerId = e.pointerId;
          try{ el.setPointerCapture(activePointerId); }catch(_){ }
        }else{
          activeTouch = true;
        }
        onDown();
      };

      const up = (e)=>{
        try{ e && e.preventDefault(); }catch{}
        if (activePointerId !== null){
          if (e && typeof e.pointerId === "number" && e.pointerId !== activePointerId) return;
          activePointerId = null;
          onUp();
          return;
        }
        if (activeTouch){
          activeTouch = false;
          onUp();
        }
      };

      if (window.PointerEvent){
        el.addEventListener("pointerdown", down, {passive:false});
        el.addEventListener("pointerup", up, {passive:false});
        el.addEventListener("pointercancel", up, {passive:false});
        el.addEventListener("lostpointercapture", ()=>up(), {passive:true});
      }

      el.addEventListener("touchstart", (e)=>down(e), {passive:false});
      el.addEventListener("touchend", (e)=>up(e), {passive:false});
      el.addEventListener("touchcancel", (e)=>up(e), {passive:false});
    };

    bindHold(document.getElementById("btnUp"),   ()=>game.input.setDir("up", true),    ()=>game.input.setDir("up", false));
    bindHold(document.getElementById("btnDown"), ()=>game.input.setDir("down", true),  ()=>game.input.setDir("down", false));
    bindHold(document.getElementById("btnLeft"), ()=>game.input.setDir("left", true),  ()=>game.input.setDir("left", false));
    bindHold(document.getElementById("btnRight"),()=>game.input.setDir("right", true), ()=>game.input.setDir("right", false));
    bindHold(document.getElementById("btnFire"), ()=>game.input.setFireDown(true),      ()=>game.input.setFireDown(false));

    const pause2 = document.getElementById("btnPause2");
    if (pause2){
      pause2.addEventListener("pointerdown", (e)=>{
        if (e.pointerType === "mouse") return;
        e.preventDefault();
        game.togglePause();
      }, {passive:false});
    }
  })();

  const overlay = document.getElementById("startOverlay");
  const startBtn = document.getElementById("startBtn");
  const restartBtn = document.getElementById("restartBtn");
  const pauseBtn = document.getElementById("pauseBtn");
  const toggleAudioBtn = document.getElementById("toggleAudioBtn");
  const toggleSfxBtn = document.getElementById("toggleSfxBtn");

  async function start(){
    overlay.style.display = "none";
    await game.audio.unlock();
  }
  startBtn.addEventListener("click", start);
  canvas.addEventListener("pointerdown", () => { if (overlay.style.display !== "none") start(); }, {passive:true});
  restartBtn.addEventListener("click", () => game.reset());

  game.onPauseChange = (paused)=>{
    pauseBtn.textContent = paused ? "ç»§ç»­" : "æš‚åœ";
  };
  pauseBtn.addEventListener("click", ()=>game.togglePause());


  let musicOn = true;
  let sfxOn = true;

  const syncAudioUI = ()=>{
    toggleAudioBtn.textContent = musicOn ? "éŸ³ä¹ï¼šå¼€" : "éŸ³ä¹ï¼šå…³";
    if (toggleSfxBtn) toggleSfxBtn.textContent = sfxOn ? "éŸ³æ•ˆï¼šå¼€" : "éŸ³æ•ˆï¼šå…³";
  };
  syncAudioUI();

  toggleAudioBtn.addEventListener("click", async ()=>{
    musicOn = !musicOn;
    game.audio.setBgmEnabled(musicOn);
    syncAudioUI();
    if (musicOn) await game.audio.unlock();
  });

  if (toggleSfxBtn){
    toggleSfxBtn.addEventListener("click", async ()=>{
      sfxOn = !sfxOn;
      game.audio.setSfxEnabled(sfxOn);
      syncAudioUI();
      if (sfxOn) await game.audio.unlock();
    });
  }

  // Touch controls are available on mobile via #touchBar.

})();
</script>
</body>
</html>
